# 项目 2：距离矢量路由

在本项目中，你将编写一个距离矢量路由协议。我们提供了模拟器代码，你可以用它来可视化你的协议运行情况。

完成本项目所需的课程内容：第 5 讲（路由 2：距离矢量）。推荐预习：第 4 讲（路由 1：原理）。

你可以独自完成本项目，也可以与一位搭档合作。你可以与项目 1 的搭档保持一致，也可以选择不同的搭档。提醒：[我们的课程政策页面有协作政策](https://su25.cs168.io/policies)，你必须遵守。

## 环境搭建

### Python 安装

本项目已在 Python 3.8 版本测试通过（它可能在更新的 Python 版本上也能运行，但请自行承担风险）。

如果在终端中运行 `python3 --version` 或 `python --version`，输出为 `Python 3.8.*` 形式，说明环境已就绪。

### 初始代码

[在此处下载初始代码](https://su25.cs168.io/assets/projects/proj2/cs168-su25-proj2-routing.zip)。

建议经常备份代码。项目的某些部分需要修改之前编写的代码，你可能需要回退更改，从较早的保存点重新开始。

你只需要编辑 `dv_router.py`。文件中有清晰的注释标明了需要填写代码的位置。

指导原则：



* 不要修改任何其他文件。

* 不要添加新文件。

* 不要添加任何导入语句。

* 不要编辑注释所指示部分之外的代码。

* 不要添加任何硬编码的全局变量。

* 添加辅助方法是允许的（在最后一部分尤其推荐）。

* 一般来说，如果我们没有告诉你要使用某个东西，你可能不需要它。我们的目标不是为难你！

在终端中，使用 `cd` 命令导航到 `cs168-su25-proj2-routing/simulator` 目录。所有 Python 命令都应从该目录运行。

### 新说明

注意：本说明为 2024 年秋季重写，更清晰且提供了一些额外提示。可能包含错误。

[如果你想使用之前版本的说明，可以在此处找到](https://sp24.cs168.io/assets/projects/routing1.pdf)。

## 项目概述

本项目分为 3 个部分，共 10 个阶段。

每个阶段都有本地提供的单元测试。你的成绩仅由这些单元测试决定（没有隐藏测试）。

要运行单元测试，请运行以下命令，将 5 替换为你要测试的阶段编号：



```
python3 dv\_unit\_tests.py 5
```

警告：第 10 阶段比其他阶段长得多，请做好规划。

## 热身示例：集线器

开始之前的一些假设：



* 在本项目中，你的代码需要找到主机之间的路由。不需要找到到其他路由器的路由。

* 在本项目中，我们的转发表将目标映射到编号的物理端口，而不是下一跳。例如，表中的一行可能表示：“发往 h1 的分组应从端口 1 发送出去”。

为了帮助你入门，我们在 `examples/``hub.py` 中提供了集线器的实现。集线器是一种网络设备，它接收任何传入的分组，并将该分组从所有端口（除了接收分组的端口）转发出去。

让我们在具有三个主机的线性拓扑上运行模拟器：



```
python3 simulator.py --start --default-switch-type=examples.hub topos.linear --n=3&#x20;
```

现在，你可以在浏览器中访问 [http://127.0.0.1:4444](http://127.0.0.1:4444/) 来查看可视化界面。你应该看到主机和路由器在紫色背景上显示。

现在，让主机 h1 向主机 h3 发送一个 ping 分组。你可以在 Python 终端中输入：



```
h1.ping(h3)
```

或者，你可以通过可视化界面发送 ping：（1）点击 h1 并按 `A`，（2）点击 h3 并按 `B`，（3）按 `P` 从 A 向 B 发送 ping。

你应该看到 “ping” 分组从 h1 发送到 h3。然后，你应该看到回复的 “pong” 分组从 h3 发送到 h1。你还应该看到这两个分组都被传送到 h2，尽管 h2 不是接收者。这种行为是正常的，因为集线器会将分组泛洪到所有地方。

你也可以通过阅读打印到 Python 终端的日志消息来观察发生的情况（你可以忽略 TTL 字段，在本项目中不会用到它）。



```
WARNING:user:h2:NOT FOR ME: \<Ping h1->h3 ttl:17> s1,s2,h2

DEBUG:user:h3:rx: \<Ping h1->h3 ttl:16> s1,s2,s3,h3

WARNING:user:h2:NOT FOR ME: \<Pong \<Ping h1->h3 ttl:16>> s3,s2,h2

DEBUG:user:h1:rx: \<Pong \<Ping h1->h3 ttl:16>> s3,s2,s1,h1
```

回顾课堂内容，当网络存在环路时，泛洪会出现问题。让我们通过启动具有环路的 `topos.candy` 拓扑的模拟器来实际看看：



```
python3 simulator.py --start --default-switch-type=examples.hub topos.candy
```

现在，从主机 h1a 向主机 h2b 发送 ping。你应该会在终端中看到更多的日志消息，并且可视化界面应该会显示路由器在很长一段时间内转发多余的分组。哎呀！你在本项目中的任务是实现一个功能更强的距离矢量路由器。

你不需要修改或提交本节的任何内容。

## 代码概述

你将在 `dv_router.py` 中实现 `DVRouter` 类，该类表示单个路由器。

`dv.py` 中实现了一些有用的辅助类（你可以阅读该文件，但不要修改它）。我们在下面也对它们进行了描述。

### 表（Table）

实例变量 `self.table` 是一个 `Table` 对象，表示路由器内部的转发表。

`Table` 对象是一个字典，其中键是目标，值是 `TableEntry` 对象。

每个 `TableEntry` 对象包含：



* `dst`：此路由的目标。

* `port`：发往该目标的分组应从其发送出去的端口。

* `latency`：从该路由器到目标的路由的延迟（“成本”）。

* `expire_time`：该路由过期的时间戳（以秒为单位）。使用 `api.current_time()` 获取当前时间，添加秒数来表示未来的时间。

`TableEntry` 对象是不可变的，因此如果你想更新一个条目，应该创建一个具有更新属性的新 `TableEntry`。

示例用法：



```
t = Table()

t\[h1] = TableEntry(dst=h1, port=p1, latency=10, expire\_time=api.current\_time()+20)

t\[h2] = TableEntry(dst=h2, port=p2, latency=20, expire\_time=api.current\_time()+20)

for host, entry in t.items(): # <-- 这是迭代字典的方式。

&#x20; print("到 {} 的路由延迟为 {}".format(host, entry.latency))
```

这对应如下的表：



| 键（Key）          | 值（TableEntry）   |          |             |                   |
| --------------- | --------------- | -------- | ----------- | ----------------- |
| 目标（Destination） | 目标（Destination） | 端口（Port） | 延迟（Latency） | 过期时间（Expire Time） |
| h1              | h1              | p1       | 10          | 20 秒后             |
| h2              | h2              | p2       | 20          | 20 秒后             |

### 端口（Ports）

实例变量 `self.ports` 是一个 `Ports` 对象，表示连接到路由器的链路。

`Ports` 对象包含一个字典，其中每个键是链路（端口），对应的值是该链路上的延迟（成本）。

要获取连接到端口 `p` 的链路上的延迟，可以使用：



```
self.ports.get\_latency(p)
```

要迭代所有端口，可以使用：



```
for p in self.ports.get\_all\_ports():
```

### 标志（Flags）

以下标志标识路由器所处的模式。我们会告诉你何时在代码中使用它们。你的代码不应将这些标志重新赋值为 True 或 False。



* `self.SPLIT_HORIZON`（水平分割）

* `self.POISON_REVERSE`（毒性逆转）

* `self.POISON_ON_LINK_DOWN`（链路断开时毒化）

* `self.POISON_EXPIRED`（毒化过期路由）

* `self.SEND_ON_LINK_UP`（链路启动时发送）

## 阶段 1：安装静态路由

对于每个直接连接到你的路由器的主机，你应该记录一条到该主机的静态路由。

### 任务

实现 `add_static_route` 方法。

为新路由分配 `FOREVER`（永久）的过期时间。

框架会在需要安装新静态路由时自动调用你在这里编写的代码。

### 测试与调试

要检查你的工作，请运行单元测试：



```
python3 dv\_unit\_tests.py 1
```

要调试，可以启动模拟器，并使用终端打印每个路由器内部的表。例如，要打印 `s1` 内部的表：



```
print(s1.table)
```

如果你在自己编写的代码中调试，可以像这样打印自己的表：



```
print(self.table)
```

### 理解检查

现在我们已经实现了静态路由，如果你尝试沿路径发送分组，预期会发生什么？

为了找出答案，启动模拟器并在浏览器中打开 [http://127.0.0.1:4444](http://127.0.0.1:4444/)：



```
python3 simulator.py --start --default-switch-type=dv\_router topos.simple
```

尝试从主机 h1 向主机 h2 发送 ping，例如在终端中输入 `h1.ping(h2)`。

发生了什么？与你的预期一致吗？

## 阶段 2：转发

我们已经在路由表中添加了条目，但需要实际使用它们来转发分组。

### 任务

实现 `handle_data_packet` 方法。

每当有数据分组到达你的路由器时，框架会调用此方法。

提示：要将给定的 `packet` 从给定的 `port` 发送出去，可以使用：



```
self.send(packet, port=port)
```

如果分组的目标没有路由，则应丢弃该分组（不执行任何操作）。

如果出链路的延迟大于或等于 `INFINITY`（无穷大），也应丢弃该分组。

### 测试与调试

要检查你的工作，请运行单元测试：



```
python3 dv\_unit\_tests.py 2
```

### 理解检查

再次启动上一阶段的模拟器：



```
python3 simulator.py --start --default-switch-type=dv\_router topos.simple
```

再次尝试从主机 h1 向主机 h2 发送 ping，例如在终端中输入 `h1.ping(h2)`。希望这次分组到达了！

你已经完成了第一部分！接下来，让我们在表中添加更多路由。

## 阶段 3：发送通告

### 理解检查

在我们当前的实现下，当在这些拓扑中从一个主机向另一个主机发送 ping 时，会发生什么？

拓扑 1：`h1 --- s1 --- h2`

拓扑 2：`h1 --- s1 --- s2 --- h3`

ping 在两个拓扑中都能工作吗？还是只有一个能工作？或者都不能？

为了找出答案，再次启动模拟器来运行这两种场景：



```
python3 simulator.py --start --default-switch-type=dv\_router topos.simple
```

在拓扑 2 中存在问题。路由器集体知道两个目标，但每个路由器本身并不知道两个目标。

为了解决这个问题，让我们让路由器交换通告，以便它们可以了解网络中的其他目标。

### 任务

实现 `send_routes` 方法。

目前，你可以假设 `force=True` 且 `single_port=None`，忽略这些参数。

框架会定期为你调用此函数，以便你的路由器定期向所有邻居通告路由。

提示：要从特定的 `port` 发送一条消息，表明你可以以特定的 `latency` 到达特定的 `dst`，可以使用：



```
self.send\_route(port, dst, latency)
```

### 测试与调试

要检查你的工作，请运行单元测试：



```
python3 dv\_unit\_tests.py 3
```

### 理解检查

现在，如果我们尝试在拓扑 1 和拓扑 2 中发送 ping，会发生什么？

为了找出答案，再次启动模拟器并尝试。你会注意到路由通告（紫色点）定期从每个路由器发送出去。

但是，拓扑 2 中的 ping 仍然无法工作。

## 阶段 4：处理通告

你的路由器现在会发送通告，但它也需要处理收到的任何通告！特别是，我们需要实现距离矢量的规则 1（贝尔曼 - 福特更新）和规则 2（来自下一跳的更新）。

### 任务

实现 `handle_route_advertisement` 方法。

每当你的路由器收到通告时，框架会为你调用此方法。

如果通告的路由与当前路由同样好，则通过优先选择当前路由来打破平局。换句话说，只有当通告的路由**严格优于**当前路由时，才接受它。

提醒：如果你收到一个不在表中的目标的通告，应该始终接受它。

提醒：如果你收到来自当前下一跳的通告，应该始终接受它。这是距离矢量的规则 2（来自下一跳的更新）。

如果更新表，将新条目的过期时间设置为 `api.current_time()+self.ROUTE_TTL`（默认情况下，这是未来 15 秒）。

### 测试与调试

要检查你的工作，请运行单元测试：



```
python3 dv\_unit\_tests.py 4
```

### 理解检查

我们为什么选择通过优先选择当前路由来打破平局？如果我们优先选择新路由会怎样？

这里在**正确性**和**稳定性**之间存在权衡。

要理解稳定性的含义，暂时修改你的实现，通过优先选择新路由来打破平局（如果通告的路由与当前路由同样好，则接受它）。

然后，使用方形拓扑启动模拟器：



```
python3 simulator.py --start --default-switch-type=dv\_router topos.square
```

在正方形的两个角之间发送大量 ping。注意，同一两个主机之间的分组可能走不同的路径。我们认为这是不稳定的，并且不是最优的。

（预览：走不同路径的分组可能会乱序到达，这会导致四层可靠性协议 TCP 减速。）

现在，撤销你的临时更改，再次通过优先选择当前路由来打破平局（只有当通告的路由严格更好时才接受）。

然后，再次启动模拟器并再次发送大量 ping。现在，我们的分组总是走相同的路径！

那么，权衡是什么？优先选择当前路径更稳定。另一方面，新路由代表更新的状态，因此更能反映网络的当前状态。

## 阶段 5：处理超时

接下来，让我们实现距离矢量的规则 3（过期）。

### 理解检查

如果链路断开会发生什么？为了找出答案，使用 candy 拓扑启动模拟器：



```
python3 simulator.py --start --default-switch-type=dv\_router topos.candy
```

等待所有路由传播。然后，移除路由器 s4 和 s5 之间的链路。你可以在浏览器中选择两个路由器并按 `E`，或者在终端中输入 `s4.unlinkTo(s5)`。

现在，尝试从 h1a 向 h2b 发送 ping。尽管仍然有通过 s3 的路径，但你会看到分组被转发到 s4，然后被丢弃！

路由器 s4 正试图转发到 s5，但它已经不再连接到 s5 了！

### 任务

实现 `expire_routes` 方法。

框架会定期为你调用此函数。你的工作是遍历转发表条目，并删除任何已过期的条目。

可选，不评分：删除过期路由时，可以使用 `self.s_log` 或 `self.log` 在终端中打印消息。

提示：要删除键为 `h` 的表条目，可以使用：



```
self.table.pop(h)
```

### 测试与调试

要检查你的工作，请运行单元测试：



```
python3 dv\_unit\_tests.py 5
```

### 理解检查

再次使用 candy 拓扑启动模拟器：



```
python3 simulator.py --start --default-switch-type=dv\_router topos.candy
```

再次断开链路，例如 `s4.unlinkTo(s5)`。开始从 h1a 向 h2b 发送大量 ping。链路断开后大约 15 秒，旧路由将过期，未来的 ping 应该会沿着替代路径正确转发！

你已经完成了第二部分！接下来，让我们使路由器更高效。

## 阶段 6：水平分割

接下来，让我们实现距离矢量的规则 6A（水平分割）。

### 理解检查

使用具有 3 个主机的线性拓扑启动模拟器：



```
python3 simulator.py --start --default-switch-type=dv\_router topos.linear --n=3
```

等待所有路由传播。

从 h3 向 h1 发送 ping。这应该能工作。

接下来，断开 s1 和 s2 之间的链路，例如 `s1.unlinkTo(s2)`。

现在，尝试从 h3 向 h1 发送 ping。你应该看到分组在 s2 处被丢弃。

最终，s2 的路由将超时，s2 将从 s3 收到新的通告。现在，当你从 h3 向 h1 发送 ping 时，会发生什么？为什么？

这种路由环路会持续多久？更大的问题是什么？我们如何解决这个问题？

### 任务

修改 `send_routes` 方法，以便在 `self.SPLIT_HORIZON` 标志为 True 时支持水平分割。

### 测试与调试

要检查你的工作，请运行单元测试：



```
python3 dv\_unit\_tests.py 6
```

### 理解检查

在代码中设置 `self.SPLIT_HORIZON` 为 True，再次运行相同的演示。路由环路问题现在应该得到解决了！

## 阶段 7：毒性逆转

接下来，让我们实现距离矢量的规则 6B（毒性逆转）。

### 理解检查

设置 `self.SPLIT_HORIZON` 为 False，使用双三角形拓扑启动模拟器：



```
python3 simulator.py --start --default-switch-type=dv\_router topos.double\_triangle
```

通过删除所有连接 s2 与其他路由器的链路来断开 s2：



```
s2.unlinkTo(s1)

s2.unlinkTo(s3)

s2.unlinkTo(s4)
```

让我们看看水平分割是否能拯救我们！打开水平分割并重新运行演示。

我们能做得更好吗？如何做？

### 任务

修改 `send_routes` 方法，以便在 `self.POISON_REVERSE` 标志为 True 时实现毒性逆转通告。

注意：`self.POISON_REVERSE` 和 `self.SPLIT_HORIZON` 永远不会同时为 True。它们可以都为 False，或者其中一个为 True。

### 测试与调试

要检查你的工作，请运行单元测试：



```
python3 dv\_unit\_tests.py 7
```

### 理解检查

设置 `self.POISON_REVERSE` 为 True，再次运行前面的双三角形演示。现在需要多长时间才能达到正确状态？

## 阶段 8：计数到无穷大

接下来，让我们实现距离矢量的规则 7（计数到无穷大）。

### 理解检查

回顾一下，水平分割和毒性逆转可以防止长度为 2 的路由环路，但不能防止更长的环路。

为了理解原因，使用 loopy 拓扑启动模拟器：



```
python3 simulator.py --start --default-switch-type=dv\_router topos.loopy
```

等待所有路由传播。

断开 s1 与 s2 的连接，例如 `s2.unlinkTo(s1)`。

你可以在终端中打印转发表，例如 `print(s1)`。路由器会计数多久？看起来是永远…… 尽管我们付出了很多努力！

我们最终会稳定下来吗？水平分割或毒性逆转能解决问题吗？

### 任务

修改 `send_routes` 方法，以便在通告时，任何大于 `INFINITY` 的延迟都向下取整为 `INFINITY`。

### 测试与调试

要检查你的工作，请运行单元测试：



```
python3 dv\_unit\_tests.py 8
```

常见错误：在阶段 2 中，不要忘记如果表中的距离是 `INFINITY`，就不应该转发数据分组。如果你忘记了这一点，测试在阶段 8 才会发现你的错误。

### 理解检查

再次运行前面的 loopy 演示。现在路由器会计数多久？

## 阶段 9：毒化过期路由

接下来，让我们实现距离矢量的规则 5（毒化过期路由）。

### 理解检查

使用具有 7 个主机的线性拓扑启动模拟器：



```
python3 simulator.py --start --default-switch-type=dv\_router topos.linear --n=7
```

等待所有路由收敛（例如，s7 的表应该有到 h1 的路由）。这可能需要一段时间！

然后，断开 s1 与 s2 的连接，例如 `s1.unlinkTo(s2)`。

其他路由器中的到 s1 的路由需要多长时间才能更新？

### 任务

修改 `expire_routes` 方法。

如果 `self.POISON_EXPIRED` 为 True，所有过期的路由都应替换为毒化路由。

将毒化条目的过期时间设置为 `api.current_time()+self.ROUTE_TTL`。这确保毒化路由会定期被通告。

可选，不评分：理想情况下，定期通告应该在一段时间后停止（即毒化路由最终应该被删除），因为持续通告路由不存在的信息没有意义。但我们不会对此进行测试。

### 测试与调试

要检查你的工作，请运行单元测试：



```
python3 dv\_unit\_tests.py 9
```

### 理解检查

现在路由删除的传播相对于什么而言更快了？

你快完成了！现在可能是备份工作的好时机。最后一个阶段需要修改你到目前为止编写的代码，你可能希望在开始阶段 10 之前恢复到之前的代码。

## 阶段 10A：增量触发更新

计时器提供了最终收敛的良好保证。但是，响应网络事件执行操作会带来更优的性能。

在本阶段，你将实现增量和触发更新。你的路由器将在其表更新时通告路由（触发），并且只通告已更改的路由（增量）。

### 任务

修改 `send_routes` 方法以处理 `force=False` 的情况。

如果 `force=False`，你应该只在路由与之前沿该端口发送的路由不同，或者之前从未沿该端口发送过该路由时，才从该端口通告路由。

在 `__init__` 构造函数中，你可以添加 `self.history` 数据结构。这可以帮助你记录每个端口最近为每个目标发送的通告。

提示：



* 不要大量复制粘贴代码。不要反复复制粘贴相同的代码。如果你的代码很混乱，我们不会帮助调试。

* 辅助方法可以帮助你清理代码。我的解决方案使用了两个辅助方法。

然后，修改 `handle_route_advertisement` 方法，以便在表更新时调用 `self.send_routes(force=False)`。

### 测试与调试

要检查你的工作，请运行单元测试：



```
python3 dv\_unit\_tests.py 10
```

此时，阶段 10 的 28/31 测试应该通过，你应该看到：`.........FF.F..................`

## 阶段 10B：链路上下的触发更新

我们要做的最后一件事是在连接到你的路由器的链路断开或新链路连接到你的路由器时触发更新。

### 任务



1. 实现 `handle_link_up` 方法。

   当连接到此路由器的链路启动时，框架会调用此函数。

   如果 `self.SEND_ON_LINK_UP` 为 True，你的路由器应该通过立即仅向该端口通告其所有路由，让新邻居了解情况。使用 `send_routes` 的 `single_port` 参数来帮助实现。

2. 接下来，编辑 `send_routes` 方法。

   如果 `single_port` 不为 None，`send_routes` 应该只向指定的单个端口发送更新，而不向任何其他端口发送。

3. 最后，实现 `handle_link_down` 方法。

   当连接到此路由器的链路断开时，框架会调用此函数。

   如果 `self.POISON_ON_LINK_DOWN` 为 True，此函数应该用毒化路由替换所有使用该端口的路由。然后，立即向所有邻居通告新的毒化路由。

   如果 `self.POISON_ON_LINK_DOWN` 为 False，此函数应该删除所有使用该端口的路由。

   提示：要删除键为 `h` 的表条目，可以使用：



```
self.table.pop(h)
```

### 测试与调试

要检查你的工作，请运行单元测试：



```
python3 dv\_unit\_tests.py 10
```

此时，阶段 10 中剩余的 3 个测试应该通过，因此 31/31 测试通过。

常见错误：链路断开时，确保使用 `force=False` 来增量通告。

### 理解检查

使用你喜欢的任何拓扑启动模拟器。与早期版本的路由器相比，你现在应该看到对网络事件的响应时间大大缩短。

如果我们现在有事件，计时器的目的是什么？

## 提交与评分

恭喜！你已经实现了一个距离矢量协议的变体路由器。你的实现非常接近现实世界的路由信息协议（RIP）。

如果你完全完成了项目，当你运行所有单元测试时，应该看到 100/100 的分数：



```
python3 dv\_unit\_tests.py 10
```

要提交项目 2，只需将 `dv_router.py` 文件提交到 [Gradescope 上的项目 2 自动评分器](https://www.gradescope.com/courses/1054987/assignments/6346819)。

你的成绩完全由单元测试计算，10 个阶段各占 10%（每个阶段 10%）。在每个阶段内，所有测试的权重相同。

如果你诚实地完成了项目（没有学术不端行为），那么你在 Gradescope 上看到的分数就是你的最终成绩。

> （注：文档部分内容可能由 AI 生成）