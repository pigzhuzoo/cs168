# Traceroute 指南

本指南包含完成 Project 1A 和 Project 1B 所需的全部知识。

本指南不依赖于任何先前的课程内容，但第 1-3 讲（入门讲座）可能会有所帮助。

[本指南的幻灯片版本](https://docs.google.com/presentation/d/1Ti4oUP0di9LXrlz3KTlMEYEwhhldMAEst8HqyRZlsq8)

## 1. 网络背景

### 1.1. 协议

在本课程中，我们的主要关注点是**协议**—— 它们规定了机器之间如何进行通信。机器交换的消息格式是什么？收到消息后应该如何响应？

使用协议的所有方都需要就数据的格式以及对不同消息的响应方式达成一致。

打个比方，想想课堂上提问的协议：首先，你要举手；要等老师叫到你才能开始提问；如果老师没叫你，你可以说 “打扰一下！” 来引起注意。

再举一个协议的例子：Alice 和 Bob 先互相打招呼，然后 Alice 请求一个文件，Bob 回复该文件。要定义这个协议，我们需要明确语法（例如，如何用 0 和 1 表示 “给我这个文件”）和语义（例如，Alice 必须收到 Bob 的打招呼消息后才能请求文件）。

不同的协议为不同的需求而设计。例如，如果 Alice 需要尽快拿到文件，我们设计的协议可能就不会包含初始的打招呼消息。

设计一个好的协议可能比看起来更难！我们还需要考虑边缘情况、漏洞和恶意行为。例如，如果 Alice 请求文件，而 Bob 回复了一个打招呼消息，Alice 应该如何响应？

### 1.2. 互联网的构建

要理解互联网的设计，我们可以先以邮政系统为类比。如何设计邮政系统呢？

**构建块 1**：我们需要一些物理技术来实现数据的空间传输。可能是邮递员步行、邮车、飞机、驿马快信、信鸽等等。

同样，在互联网中，我们需要一些物理技术来实现比特的空间传输。可能是电线上的电压、光纤上的光信号、无线无线电波等等。

**构建块 2**：利用物理技术，我们可以创建链路来连接本地城镇的所有人。

同样，在互联网中，我们可以利用物理技术将本地范围内的所有设备连接起来。



![图片](https://su25.cs168.io/assets/projects/proj1/01-lan.png)

**构建块 3**：如果想连接不同城镇的房屋，我们可以在每对房屋之间建立直接链路，但这样成本很高。



![图片](https://su25.cs168.io/assets/projects/proj1/02-mesh.png)

相反，我们可以在每个城镇设置一个邮局。这样，我们只需要一条跨城镇的链路来连接两个邮局即可。



![图片](https://su25.cs168.io/assets/projects/proj1/03-router.png)

如果我在奥克兰，想给伯克利的你寄信：我把信送到奥克兰邮局，奥克兰邮局把信转发到伯克利邮局，最后伯克利邮局把信转发给你。

有了足够多的邮局，我们就能连接世界上所有的城镇！

### 1.3. 互联网的特性

注意，我们的设计将系统分解为多个抽象层。每一层依赖于下一层提供的服务，同时为上一层提供服务。

**第 1 层（物理层）**：实现比特的空间传输。

**第 2 层（链路层）**：在本地网络中创建链路。链路层依赖于第 1 层构建的技术。

**第 3 层（互联网层）**：将本地网络连接起来形成互联网。互联网层依赖于第 2 层构建的本地网络。

互联网通常被称为 “网络的网络”。每个运营商运行自己的本地网络（可以想象成一个小镇），然后这些本地网络相互连接形成互联网。



![图片](https://su25.cs168.io/assets/projects/proj1/04-network-of-networks.png)

互联网上有两种类型的机器：

**终端主机**：实际进行通信的机器（例如你的笔记本电脑、手机、谷歌的 web 服务器）。在前面的类比中，这些相当于房屋。我们通常将终端主机画成圆形。

**路由器**（也称为交换机）：接收消息并将其转发到目的地的机器。在类比中，这些相当于邮局。我们通常将路由器画成方形。

在我们的模型中，一条链路连接两台机器。但源端和目的端不一定通过直接链路连接。

相反，消息可能需要经过多个**跳数**才能到达目的地。当路由器收到消息时，必须将消息**转发**到更接近最终目的地的地方。



![图片](https://su25.cs168.io/assets/projects/proj1/05-path-through-network.png)

目前，我们暂不讨论路由器如何确定消息的转发方向。但需要注意的是，如果你向同一个目的地发送多个消息，它们不一定都走相同的路径。

互联网只提供**尽力而为**的服务。这意味着消息可能会丢失、乱序、损坏等。网络会尽力传递消息，但不做任何保证。

如果我们需要比尽力而为更好的服务，就必须构建更多的层。

### 1.4. 更高的层

**第 4 层（传输层）**：添加额外功能（例如重传丢失的消息）以保证可靠传输。传输层还提供一种称为端口的功能（下文将详细讨论）。传输层依赖于第 3 层提供的尽力而为的全局传输服务。

**第 7 层（应用层）**：这里是我们构建实际使用互联网的程序的地方。它依赖于传输层提供的功能（可靠性、端口等）。



![图片](https://su25.cs168.io/assets/projects/proj1/06-layers.png)

在本项目中，我们的主要关注点是第 3 层（互联网层）和第 4 层（传输层）。

### 1.5. 首部

假设 A 想给 B 发送消息。

A 将消息的比特传输到路径上的下一个路由器。但路由器根本不知道如何处理这些数据包！



![图片](https://su25.cs168.io/assets/projects/proj1/07-no-headers.png)

当我们发送消息时，需要包含一些元数据，以便中间路由器和接收方知道如何处理收到的比特。

用邮政系统类比：我们必须把信放在信封里，信封上会说明如何处理这封信。

互联网上数据的基本单位是**数据包**。数据包包含一个带有消息元数据的**首部**，后面跟着包含消息本身的**载荷**。



![图片](https://su25.cs168.io/assets/projects/proj1/08-header.png)

首部中包含哪些元数据呢？

我们必须包含目的地址，这样数据包才能被送到正确的接收方。

我们通常还会包含源地址，以便接收方想要回复时能找到发送方。

在本项目中，我们不讨论这些地址的来源。我们简单假设所有机器都有唯一的 IP 地址，格式为四个用点分隔的数字（例如 3.3.3.3）。

机器也有类似 `www.berkeley.edu` 这样的人类可读名称，在项目中你可能会遇到。本项目中，我们也不讨论这些名称的来源，简单假设所有人都能根据需要在名称和地址之间进行转换（如果你想提前了解，可以看看 DNS）。

### 1.6. 多个首部

我们再回到邮政系统的类比。假设 A 公司的老板想给 B 公司的老板写一封信，消息是如何发送的呢？



![图片](https://su25.cs168.io/assets/projects/proj1/09-multiheader1.png)

A 公司的老板把信折好交给秘书，秘书把信放进写有 B 公司老板全名的信封里。



![图片](https://su25.cs168.io/assets/projects/proj1/10-multiheader2.png)

秘书把这封信交给收发室，邮递员把信放进标有 B 公司街道地址的箱子里，然后把箱子装上送货卡车。



![图片](https://su25.cs168.io/assets/projects/proj1/11-multiheader3.png)

此时，信本身被多层标识信息（信封、箱子）包裹着。快递公司将信送到 B 公司（可能经过多辆卡车、飞机、邮递员等）。



![图片](https://su25.cs168.io/assets/projects/proj1/12-multiheader4.png)

当信到达 B 公司后，收发室取下箱子，把信封交给秘书。



![图片](https://su25.cs168.io/assets/projects/proj1/13-multiheader5.png)

然后，秘书看到信封上老板的名字，取下信封，把信交给 B 公司的老板。



![图片](https://su25.cs168.io/assets/projects/proj1/14-multiheader6.png)

注意，当我们走向更低的抽象层时，会在数据周围包裹更多的首部；而当我们走向更高的抽象层时，会从数据上剥离这些首部层。



![图片](https://su25.cs168.io/assets/projects/proj1/15-wrapping-unwrapping.png)

每一层只需要理解自己的首部，并且在某种意义上是与同一层的对等方 “通信”。当 A 公司的秘书在信封上写名字时，是给 B 公司的秘书看的（而不是给邮递员或老板看的）。

更正式地说，在互联网上，同一层的对等方通过在该层建立协议进行通信。该协议只对特定层的实体有意义。



![图片](https://su25.cs168.io/assets/projects/proj1/16-layer-peers.png)

在本项目中，我们主要关注第 3 层（互联网层）和第 4 层（传输层）的首部。

这意味着我们的数据包会有一个外层的低层首部（例如第 3 层）和一个内层的高层首部（例如第 4 层）。

### 1.7. 解复用

只要发送方和接收方都同意所使用的协议栈，他们就可以选择任何想要的协议栈（通常每层一个协议）。

当接收方收到数据包时，必须解开首部，将数据包向上传递给更高层的协议。



![图片](https://su25.cs168.io/assets/projects/proj1/17-demultiplex.png)

IP 协议是如何知道要把数据包传递给 TCP 代码而不是 UDP 代码的呢？

TCP 协议是如何知道要把数据包传递给 HTTP 代码而不是 SMTP 代码的呢？

为了解决这个问题，我们会在首部中添加一个额外的字段用于**解复用**。这个首部字段告诉我们，在剥离本层首部后，应该使用什么更高层的协议来解析剩余的载荷。



![图片](https://su25.cs168.io/assets/projects/proj1/18-layer3-demultiplex.png)

### 1.8. 使用端口进行解复用

解复用在第 4 层也适用。

你电脑上每个运行的应用程序都与一个**端口号**相关联。

当第 4 层协议收到数据包时，会使用端口号将数据包传递给相应的应用程序。



![图片](https://su25.cs168.io/assets/projects/proj1/19-layer4-demultiplex.png)

用邮政系统类比：假设你和室友住在同一个地址，如果有人寄信到你家，这封信是给你还是给室友的呢？我们可以给每个室友分配房间号来区分。

注意，解复用在第 3 层和第 4 层都可以进行。在外部的第 3 层首部中，我们会写明接下来要使用的第 4 层协议；然后在内部的第 4 层首部中，我们会写明接下来要使用的应用程序。



![图片](https://su25.cs168.io/assets/projects/proj1/20-demultiplex-headers.png)

注意，如果两个应用程序之间来回交换消息，这两个应用程序都有各自的端口号。



![图片](https://su25.cs168.io/assets/projects/proj1/21-ports.png)

回想一下，第 4 层可以用于实现不同的功能，例如解复用和可靠性。不同的协议提供不同的功能。

在本项目中，我们将使用**UDP**（用户数据报协议）作为第 4 层协议。UDP 提供基于端口的解复用功能，但不提供可靠性。

免责声明：在网络中，有两个不同的东西都被称为 “端口”。我们刚才看到的是*逻辑端口*，它们是用于在软件中标识应用程序的数字。还有一个容易混淆的是*物理端口*，就是你插网线的那些接口。在本项目中，我们主要处理逻辑端口（如果有歧义会说明）。

## 2. Traceroute 介绍

### 2.1. 生存时间（TTL）

互联网上的路由器可能会有故障。



![拓扑：你的电脑 -> 1.1.1.1 -> 2.2.2.2 -> 3.3.3.3 -> 4.4.4.4 -> 3.3.3.3，在 3.3.3.3 处形成循环，目的地（5.5.5.5）永远无法到达。](https://su25.cs168.io/assets/projects/proj1/routing-loop.svg)

假设你想给 5.5.5.5 发送数据包。

你把数据包转发给 2.2.2.2。

然后，2.2.2.2 决定把数据包转发给 3.3.3.3。

现在，假设 3.3.3.3 和 4.4.4.4 是有故障的路由器。3.3.3.3 把数据包发送给 4.4.4.4，4.4.4.4 又把数据包发回给 3.3.3.3，3.3.3.3 再发回给 4.4.4.4，如此循环。我们的数据包陷入了无限循环！

如果 3.3.3.3 和 4.4.4.4 一直转发同一个数据包，那将是对资源的浪费。

为了解决这个问题，我们会在第 3 层（IP）首部中添加一个额外的字段，称为**生存时间（TTL）**。TTL 规定了数据包在过期前最多可以经过的跳数。

当路由器收到一个数据包时，会先递减 TTL（修改首部），然后再转发数据包。

如果你收到一个 TTL 为 1 的数据包，修改后 TTL 就会变为 0。这意味着数据包已经过期，所以你应该丢弃该数据包（忽略它，不再转发）。

当路由器收到一个过期的数据包时，还应该向原始发送方发送一条错误消息，让发送方知道他们的数据包被丢弃了。

### 2.2. 利用 TTL

通常，如果你发送一个数据包并收到响应数据包，你并不知道数据包所经过的路径。换句话说，你无法知道哪些中间路由器转发了你的数据包。没有任何首部字段会告诉你数据包所经过的路径。

你能想到一种利用 TTL 字段来发现你和特定目的地之间路径上的路由器的方法吗？

*手动思考区。你可以盯着下面的兔狲图片思考这个问题。在深入思考之前，兔狲要求你不要滚动查看答案。*



![兔狲图片](https://upload.wikimedia.org/wikipedia/commons/thumb/f/f5/Otocolobus_manul_by_Henry_S%C3%B6derlund.jpg/640px-Otocolobus_manul_by_Henry_S%C3%B6derlund.jpg)

*手动思考区结束。*

关键思路是：如果我们把 TTL 设置得足够小，数据包会在到达目的地之前就过期。当数据包过期时，路由器会向你发送一条错误消息。错误消息的首部会显示：“来自路由器，发给你”。这让你能够发现通往目的地路径上的一个路由器！

**traceroute** 工具通过发送 TTL 依次递增的数据包，尝试发现你和指定目的地之间路径上的所有路由器。

从高层次来说，traceroute 的工作原理如下：



![拓扑：你的电脑 -> 2.2.2.2 -> 3.3.3.3 -> 4.4.4.4 -> 5.5.5.5（目的地）](https://su25.cs168.io/assets/projects/proj1/single-path-longer.svg)

向目的地发送一个 TTL 为 1 的数据包。这个数据包会到达第一个路由器并在那里过期。第一个路由器（1.1.1.1）会向你发送一条错误消息，这样你就能发现第一个路由器。

发送一个 TTL 为 2 的数据包到目的地。这个数据包会到达第二个路由器并在那里过期。第二个路由器（2.2.2.2）会向你发送一条错误消息，让你发现第二个路由器。

发送一个 TTL 为 3 的数据包到目的地。这个数据包会到达第三个路由器（3.3.3.3）并在那里过期。第三个路由器会发送一条错误消息，让你发现它。

注意，你发送的每个数据包都是针对指定目的地的。你从来不会向中间路由器发送数据包（因为 traceroute 的意义就在于，你不知道这些路由器是谁）。

我们发送的数据包是基于 UDP 封装在 IP 中的数据包。相比之下，路由器的错误消息是基于 ICMP 封装在 IP 中的数据包。ICMP 协议有不同的首部结构，这使得路由器可以在首部中编码特定的错误类型（在这种情况下，错误是 “TTL 超时”）。

注意：在实际情况中，并非所有路由器都会返回错误消息。Traceroute 只需要打印出它发现的所有路由器（即使路径上的某些路由器没有被发现）。

### 2.3: 重复探测

到目前为止，我们的 traceroute 设计有两个小问题。



1. 互联网是尽力而为的，而我们选择的第 4 层协议（UDP）不提供可靠性。这意味着我们发送的数据包可能会丢失，路由器返回的响应数据包也可能会丢失。

2. 如果你和特定目的地之间有多个路径怎么办？可能有两个路由器都距离你 3 跳。理想情况下，我们希望发现所有路径上的路由器。



![双路径拓扑：你的电脑 -> 1.1.1.1 -> 2.2.2.2 -> 3.3.3.3 -> 6.6.6.6 -> 7.7.7.7（目的地），以及你的电脑 -> 1.1.1.1 -> 4.4.4.4 -> 5.5.5.5 -> 6.6.6.6 -> 7.7.7.7（目的地）](https://su25.cs168.io/assets/projects/proj1/multi-path.svg)

为了解决这两个问题，我们不会为每个 TTL 只发送一个数据包，而是为每个 TTL 发送多个数据包。

顺便说一下，traceroute 过程中发送的每个数据包有时被称为**探测包**。发送多个探测包有助于缓解这两个问题！



1. 探测包和响应仍然可能丢失，但我们现在发送多个探测包，因此至少有一个探测包 / 响应成功的概率增加了。

2. 如果我们发送多个探测包，我们可以尝试命中特定跳数的所有路由器。

注意，在实际情况中，不能保证我们能发现特定距离（以跳数计）的所有路由器。例如，所有 TTL 为 3 的探测包都可能走上面的路径，所以我们只能发现 3.3.3.3 而不是 5.5.5.5。为了简化，我们项目的自动评分器会神奇地保证你的探测包能命中所有路由器。

### 2.4: 不可达端口

我们如何知道 traceroute 何时完成呢？

考虑前面的例子：



![拓扑：你的电脑 -> 2.2.2.2 -> 3.3.3.3 -> 4.4.4.4 -> 5.5.5.5（目的地）](https://su25.cs168.io/assets/projects/proj1/single-path-longer.svg)

当你发送一个 TTL 为 4 的数据包时，它会到达目的地。

如果目的地不回复我们，我们就不知道已经完成了到目的地的路径追踪。我们会继续发送 TTL 为 5、6、7 等的数据包，但不会收到任何回复。

为了让目的地给我们回复，我们会故意把数据包发送到目的地的一个**不可达端口**。

回想一下，在计算机上，每个运行的服务都与一个端口号相关联。如果我们选择一个没有任何运行服务与之关联的端口号，目的计算机就会感到困惑，并返回一条 “端口不可达” 的错误消息：“你请求的端口没有对应的应用程序。”

“端口不可达” 消息是以 ICMP 封装在 IP 中的数据包形式发送的。记住：ICMP 协议有不同的首部结构，包括错误代码（在这种情况下，错误是 “端口不可达”）。

注意：这种行为很大程度上取决于目的机器的配置。为了简化，自动评分器会让所有目的地都发送 “端口不可达” 消息，但并非所有实际机器都会发送这种消息。

注意：虽然没有正式标准，但许多计算机被配置为从不使用 33434 端口，这样 traceroute 就可以使用这个端口来触发 “端口不可达” 消息。

## 3. 首部结构

在本项目中，当你实现 traceroute 时，你需要发送数据包，并填充所有必要的首部字段。

你还需要接收数据包并处理所有相关的首部字段。

在本节中，我们将重点介绍你在本项目中需要了解的相关首部字段。

### 3.1: IP 首部字段



| 字段                          | 长度（比特） | 描述                                                                                                      |
| --------------------------- | ------ | ------------------------------------------------------------------------------------------------------- |
| 版本（Version）                 | 4      | 使用的 IP 协议版本。在本项目中，我们始终使用 IPv4（版本 4）。                                                                    |
| 首部长度（Header Length）         | 4      | IP 首部的长度。以 4 字节为单位（这是因为末尾有可变长度的选项字段）。                                                                   |
| 服务类型（Type of Service）       | 8      | 用于标记高优先级数据包。本项目中不需要使用。                                                                                  |
| 总数据包长度（Total Packet Length） | 16     | 整个数据包（首部和载荷）的长度。以字节为单位。                                                                                 |
| 标识（Identification）          | 16     | 用于分片。本项目中不需要使用。                                                                                         |
| 标志（Flags）                   | 3      | 用于分片。本项目中不需要使用。                                                                                         |
| 偏移量（Offset）                 | 13     | 用于分片。本项目中不需要使用。                                                                                         |
| 生存时间（TTL）                   | 8      | 数据包过期前剩余的跳数。                                                                                            |
| 协议（Protocol）                | 8      | 应将 IP 载荷传递给哪个高层协议？本项目相关的代码：1 = ICMP，17 = UDP。                                                           |
| 校验和（Checksum）               | 16     | 用于检查数据包在传输过程中是否损坏。在本项目中，你可以忽略校验和：所有 outgoing 数据包将此字段设为 0（表示未计算校验和）；你无需验证 incoming 数据包的校验和。              |
| 源地址（Source Address）         | 32     | 发送数据包的机器的 IP 地址。                                                                                        |
| 目的地址（Destination Address）   | 32     | 目的机器的 IP 地址。                                                                                            |
| 选项（Options）                 | 可变     | 用于请求高级功能的可变长度字段。如果不需要特殊处理，此字段为空（0 字节）。在本项目中，你基本可以忽略选项：所有 outgoing 数据包不会有此字段；如果 incoming 数据包有选项，你可以忽略它们。 |

### 3.2: UDP 首部字段



| 字段                     | 长度（比特） | 描述                             |
| ---------------------- | ------ | ------------------------------ |
| 源端口（Source Port）       | 16     | 发送此数据包的应用程序的端口号。               |
| 目的端口（Destination Port） | 16     | 我们要联系的目的端应用程序的端口号。             |
| 数据包长度（Packet Length）   | 16     | 整个数据包（首部和载荷）的长度。以字节为单位。        |
| 校验和（Checksum）          | 16     | 用于检查数据包在传输过程中是否损坏。本项目中可以忽略校验和。 |

### 3.3: ICMP 首部字段



| 字段                     | 长度（比特） | 描述                                         |
| ---------------------- | ------ | ------------------------------------------ |
| 类型（Type）               | 8      | 错误类型。本项目相关的代码：3 = 目的不可达，11 = 时间超时。         |
| 代码（Code）               | 8      | 错误代码。本项目相关的代码：3 = 目的端口不可达，0 = TTL 过期。      |
| 校验和（Checksum）          | 16     | 用于检查数据包在传输过程中是否损坏。本项目中可以忽略校验和。             |
| 首部其余部分（Rest of Header） | 32     | 内容因 ICMP 类型和代码而异。在本项目的 ICMP 错误中，这些位始终设为 0。 |

ICMP 载荷包含触发错误的原始数据包（基于 UDP 的 IPv4 数据包）的首部副本。

## 推荐参考资料

Traceroute：



* [维基百科上的 Traceroute](https://en.wikipedia.org/wiki/Traceroute)

* [BSD Traceroute 手册页](https://man.freebsd.org/cgi/man.cgi?query=traceroute)

* [Linux Traceroute 手册页](https://linux.die.net/man/8/traceroute)

协议：



* [维基百科 IPv4（数据包结构）](https://en.wikipedia.org/wiki/Internet_Protocol_version_4#Packet_structure)

* [维基百科 UDP（UDP 数据报结构）](https://en.wikipedia.org/wiki/User_Datagram_Protocol#UDP_datagram_structure)

* [维基百科 ICMP（数据报结构）](https://en.wikipedia.org/wiki/Internet_Control_Message_Protocol#Datagram_structure)

* [IP RFC](https://datatracker.ietf.org/doc/html/rfc791)

* [UDP RFC](https://datatracker.ietf.org/doc/html/rfc768)

* [ICMP RFC](https://datatracker.ietf.org/doc/html/rfc792)

> （注：文档部分内容可能由 AI 生成）