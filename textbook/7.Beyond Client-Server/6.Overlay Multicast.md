# 覆盖多播

## 覆盖多播的简要历史

回顾一下，IP 多播是在 20 世纪 90 年代和 21 世纪初发展起来的。21 世纪初，IP 多播的部署进展缓慢，部分原因是我们前面讨论过的那些问题。因此，许多初创公司应运而生，包括 FastForward Networks（伯克利）、ProxyNet（伯克利）、Sightpath（麻省理工学院）和 Akamai（麻省理工学院）。它们的工作在很大程度上是独立的，但解决方案都采用了基于覆盖的多播这一相同的基本思想。

## 覆盖多播：定义

回顾一下我们在 IP 多播中遇到的一个主要问题：在不同网络之间实现多播很困难。在这个 diagram 中，如果所有主机都属于同一个组，那么不同网络中的路由器很难协同工作，将数据包发送到整个组。



![img](https://textbook.cs168.io/assets/beyond-client-server/7-051-overlay-before.png)

我们的解决方案是构建一个*虚拟网络拓扑*，直接将主机彼此连接起来：



![img](https://textbook.cs168.io/assets/beyond-client-server/7-052-overlay-after.png)

我们这里绘制的虚拟链路是虚构的，并不实际对应现实中的物理链路。例如，如果 A 想沿着那条虚拟链路向 D 发送数据包，数据包仍然必须经过几个真实的路由器和链路。

然而，通过绘制这些虚拟链路，我们现在可以假设所有主机都连接在一个小型本地网络中。然后，这些主机可以运行多播路由算法，在彼此之间转发数据包。



![img](https://textbook.cs168.io/assets/beyond-client-server/7-053-overlay-tables-1.png)

例如，我们可以使用虚拟链路构建一个以 D 为根的基于核心的树。然后，每个人都可以通过沿着树的虚拟链路广播数据包来进行多播。

请记住，当数据包沿着虚拟链路发送时，它仍然必须经过几个真实的路由器和链路。例如，如果 A 想将数据包转发给 D 和 B，它必须发送两个单播数据包：“从 A 到 D” 和 “从 A 到 B”。这两个单播数据包都将经过几个真实的路由器和链路到达目的地。

在下面的例子中，A 正在向 G 发送一个单播数据包。数据包经过几个真实的路由器和链路到达 G。途中，中间主机 C 和 D 接收并转发该数据包。



![img](https://textbook.cs168.io/assets/beyond-client-server/7-055-overlay-forward-1.png)

直观地说，虚拟网络给我们一种错觉，即所有主机都连接在一个小型本地网络中，尽管它们在现实中分布在世界各地。

从网络架构的角度来看，终端主机（在第 7 层）现在负责运行多播协议。终端主机现在充当**虚拟路由器**。这意味着终端主机必须构建多播转发表，了解它们的出站虚拟链路（例如，在静态表项中），并沿着虚拟链路转发数据包。路由器根本不需要考虑多播（它们可以只运行标准的单播协议）。

这与 IP 多播不同，在 IP 多播中，路由器负责运行多播协议，而终端主机不需要考虑这些协议（它们只需将数据包发送到组地址即可）。

我们绘制的虚拟链路形成了**覆盖网络**。覆盖网络中的终端主机（虚拟路由器）相互通信，以运行多播路由算法。覆盖路由表基于虚拟链路（例如，B 的表可能会说，如果我从 A 收到数据包，就将它们转发给 C 和 D）。

负责沿着虚拟链路发送数据包的真实链路和路由器形成了**底层网络**。底层网络路由器相互通信，以运行标准的单播路由算法（例如，距离向量、BGP）。底层路由表基于物理链路（例如，R1 的表可能会说，到 G 的下一跳是 R2）。



![img](https://textbook.cs168.io/assets/beyond-client-server/7-054-overlay-tables-2.png)

为了实现覆盖网络和底层网络，我们将使用封装。假设我们想将数据包多播到组地址。那么，内部头部（覆盖层）会说 “从 A 到 G1”，主机将读取这个覆盖层数据包来决定如何转发数据包。

假设主机 A 决定这个数据包需要沿着到 C 的虚拟链路转发。那么主机 A 会用一个外部头部 “从 A 到 C” 来封装这个数据包，并将这个数据包单播到 C。底层网络负责使用外部头部将单播数据包从 A 转发到 C。



![img](https://textbook.cs168.io/assets/beyond-client-server/7-056-overlay-forward-2.png)



![img](https://textbook.cs168.io/assets/beyond-client-server/7-057-overlay-forward-3.png)



![img](https://textbook.cs168.io/assets/beyond-client-server/7-058-overlay-forward-4.png)

## 实现覆盖网络

在最基本的模型中，覆盖网络中的节点是终端主机（例如，你的个人笔记本电脑）。这意味着终端主机需要理解多播路由协议，构建自己的转发表，并转发数据包。

终端主机也可以是一些公司安装的代理服务器（类似于 CDN 服务器）。这些机器仍然是运行多播路由协议的终端主机，但它们不是实际的用户机器（例如，你的个人笔记本电脑），而是专门为支持多播路由而部署的。请注意，这些代理服务器仍然是在覆盖层中运行多播路由的终端主机。这些服务器仍然需要封装数据包，并通过底层网络单播它们，因此这些服务器不是第 3 层路由器。

覆盖网络的一般思想除了多播之外，还可以用于其他目的。例如，数据包也可以通过覆盖网络进行单播。你可以使用覆盖拓扑构建对等文件共享服务（对等服务是指组中的任何用户都可以与其他任何用户共享文件，而不依赖于存储所有文件的中央服务器）。

许多覆盖网络可以同时共存于同一个底层网络之上。从终端主机的角度来看，终端主机将运行两个独立的应用程序。每个应用程序都有自己独立的转发表、相邻链路列表等。每个应用程序可以提供不同的服务。

## 覆盖多播的优点

覆盖多播方法有什么好处呢？

最大的好处是易于部署。从底层路由器的角度来看，覆盖网络只是另一个发送和接收单播数据包的应用程序。底层路由器和协议不需要任何修改。

IP 多播需要大多数或所有路由器都理解多播协议。相比之下，在覆盖多播中，只有某些参与节点（例如，组中的用户）需要理解该协议。所有其他终端主机都不需要任何修改。

每个覆盖多播应用程序都可以使用自己的实现或协议，因此不同应用程序（例如，不同的组）之间不需要标准化。相比之下，在 IP 多播中，所有路由器都需要使用相同的协议，以便它们可以相互协调。

由于每个覆盖多播应用程序都可以做出自己的实现决策，这种方法也给应用程序提供了定义自己目标的自由。

每个应用程序都可以决定如何绘制它们的虚拟拓扑、如何设置它们的链路成本以及如何计算通过网络的路径。有些组可能更关心延迟，而其他组可能更关心吞吐量。

与 IP 多播相比，覆盖多播中的访问控制也更容易。路由协议的实现可以进行定制，只允许授权用户参与协议。每个应用程序都可以自己决定授权用户的标准。

每个应用程序还可以决定自己的商业模式。路由协议的实现可以进行定制，以跟踪使用情况并向用户收费，每个应用程序都可以自己决定跟踪使用情况的方式。例如，CDN 服务器的覆盖网络可能用于向数百万用户流式传输体育比赛。应用程序本身可以跟踪哪些用户在观看体育比赛，并相应地向他们收费。

也存在更特殊的商业模式。例如，对等文件共享系统可能被用于非法流式传输受版权保护的材料。这种系统可能希望避免跟踪用户，以避免给用户带来麻烦。

## 覆盖多播的性能

覆盖网络的性能在很大程度上取决于终端主机之间绘制的虚拟拓扑。特别是，虚拟拓扑中的链路和成本应该准确反映相应的底层拓扑。

例如，这个覆盖网络拓扑与相应的底层拓扑非常匹配。



![img](https://textbook.cs168.io/assets/beyond-client-server/7-059-underlay-1.png)

从 A 到 C 的虚拟链路可以被分配较低的成本，因为实际上 A 和 C 彼此距离很近（底层路径经过 3 个路由器）。从 D 到 G 的虚拟链路可以被分配较高的成本，因为实际上 D 和 G 距离更远（底层路径经过 5 个路由器）。如果我们在覆盖拓扑中计算最短路径，得到的路径应该与底层拓扑中的最短路径非常相似。通过底层网络获得短路径是可取的，因为数据包最终是通过底层网络转发的。

在这个特定的覆盖拓扑中，从 A 到 G 的数据包最终沿着一条与最短路径非常接近的路径转发。

下面是一个不能很好地模拟相应底层拓扑的覆盖网络示例。



![img](https://textbook.cs168.io/assets/beyond-client-server/7-060-underlay-2.png)

请注意，我们没有改变底层拓扑的任何内容。我们只改变了虚拟链路的位置。

在这个特定的覆盖拓扑中，如果我们尝试计算从 A 到 G 的最短路径，我们会得到从 A 到 C 到 B 到 E 到 F 到 G 的路径。如果我们然后沿着这条路径发送数据包，从 A 到 G 的数据包最终会沿着底层网络中一条差得多的路径转发。

为了衡量覆盖网络的性能，我们可以定义**拉伸因子**。它是底层路径成本与覆盖路径成本的比率。



![img](https://textbook.cs168.io/assets/beyond-client-server/7-061-stretch.png)

在上面的例子中，底层成本是 4，覆盖成本是 1，这给我们的拉伸因子是 4。为了更好地模拟底层网络，将虚拟链路的成本分配为 4 可能更有意义。

高拉伸值是不好的，因为这意味着底层路径比相应的覆盖路径长很多倍。理想情况下，我们希望拉伸值更低（更接近 1），这意味着我们的底层路径成本与覆盖路径成本大致相同。

我们如何构建低拉伸的覆盖拓扑呢？有时，运营商会手动设计拓扑。

也存在用于自动发现良好覆盖拓扑的自组织协议。从高层次来看，自组织协议的工作方式可能如下：最初，你的邻居是随机选择的（即，从你到随机邻居绘制虚拟链路）。定期地，你会搜索新的候选邻居，并测量你到这些新候选邻居的距离（例如，发送一个数据包并测量往返时间）。如果最佳候选邻居比你当前最差的邻居表现更好，那么就放弃你最差的当前邻居（删除虚拟链路），并添加最佳候选邻居（添加新的虚拟链路）。

## 覆盖多播的缺点

覆盖多播会带来额外的开销，这会影响性能。例如，封装和解封装数据包需要额外的时间和处理能力。

覆盖多播不是互联网内置的，这意味着应用程序开发人员必须自己实现覆盖多播。相比之下，在 IP 多播中，应用程序开发人员只需将数据包发送到组地址，而不必构建自己的转发表等。

尽管存在这些缺点，覆盖多播的性能已经足够好，以至于它在当今的互联网中被广泛部署。

> （注：文档部分内容可能由 AI 生成）