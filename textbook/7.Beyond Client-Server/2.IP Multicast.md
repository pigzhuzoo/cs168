# IP 多播

## IP 多播的简要历史

IP 多播在 20 世纪 90 年代和 21 世纪初得到了积极的研究和开发。其发展的动力源于人们的预期，即互联网的杀手级应用将是直播电视或广播。（有趣的事实：最早的直播音乐会之一是 1994 年的滚石乐队演唱会。）

回顾过去，20 世纪 90 年代和 21 世纪初开发的 IP 多播协议在采用方面取得了喜忧参半的成果。现代路由器确实支持我们将要看到的 IP 多播协议，但网络运营商并不总是在路由器上启用这些协议。（在路由器上禁用该协议本质上意味着路由器不理解或不支持该协议。）

IP 多播协议有时在单个域内使用（例如，在数据中心网络内部）。然而，IP 多播协议很少 / 从未在不同域之间部署。这意味着用户不能期望在全球互联网层面使用 IP 多播，例如，如果世界各地的一群用户加入一个多播组，现代互联网不会自动支持向该组多播数据包。

尽管这些协议没有在全球范围内部署，但这些协议中使用的技术可以应用于解决不同的网络问题。特别是，这些技术在解决与 AI 训练相关的问题时再次变得重要（我们将在讨论集合通信时研究这一点）。

## IP 多播服务模型

我们如何定义一个组？每个多播组由一个 IP 地址定义。224.0.0.0 到 239.255.255.255 范围内的地址是多播地址，并且每个人都知道这个硬编码范围内的地址是多播地址。



![img](https://textbook.cs168.io/assets/beyond-client-server/7-005-multicast-addresses.png)

要加入一个组，你需要宣告你想要加入的组的多播地址。至少有一个路由器（例如，你的家庭路由器）应该能收到你的消息，然后路由器之间会相互协调以传播这些信息（例如，通过路由协议）。最终，所有路由器都会知道你是该组的一部分。



![img](https://textbook.cs168.io/assets/beyond-client-server/7-006-join-message.png)

同样，你可以宣告你要离开一个组，并且你同样使用多播地址来标识你所谈论的是哪个组。



![img](https://textbook.cs168.io/assets/beyond-client-server/7-007-leave-message.png)

要向一个组发送数据包，你所需要做的就是将多播组地址填入 IP 目的字段。然后，路由器将使用该组地址将数据包转发给所有组成员。请注意，作为发送者，你无需担心谁属于该组，因为路由器会为你处理这一点。



![img](https://textbook.cs168.io/assets/beyond-client-server/7-008-multicast-forwarding.png)

总之，IP 多播服务模型为终端主机定义了三种操作：你可以向一个组发送数据包（即使你自己不是该组的一部分）；你可以宣告加入一个组；你可以宣告离开一个组。在这三种操作中，你的工作只是发送数据包。路由器将处理这些数据包，相互协调（例如，运行路由协议），并决定如何相应地路由多播数据包。

现在我们知道了主机如何与 IP 多播交互（发送、加入和离开），我们可以思考路由器如何交付多播数据包。

在单播模型中，路由器接收数据包并将其沿着单个下一跳转发。而在 IP 多播模型中，当路由器接收到多播数据包（即目的地是多播组地址）时，路由器将沿着零个、一个或多个出站链路转发数据包，以便数据包到达所有组成员。

为了实现多播，路由器需要一些额外的状态来跟踪组成员身份，以便路由器只能将数据包转发到通向组成员的下一跳。如果某个下一跳不会通向任何组成员，就没有必要沿着该下一跳发送数据包。当用户加入和离开组时，路由器针对该组的下一跳可能会发生变化。

## 实现多播

定义了我们的服务模型后，我们现在可以在路由器中实现 IP 多播了。记住我们的最终目标：用户通过发送数据包、宣告加入和宣告离开与网络交互。路由器必须获取这些信息，并使用它们将多播数据包正确转发到该组的所有成员（由多播地址定义）。

我们可以将这个问题分为两部分：



1.  路由器如何知道其直接连接的主机属于哪些组？我们将使用一种称为 IGMP 的协议来解决这个问题。



![img](https://textbook.cs168.io/assets/beyond-client-server/7-009-igmp-taxonomy.png)



1.  路由器如何通过网络转发数据包以到达目的地组成员？我们将研究两种解决此问题的协议：DVMRP 和 CBT。这两种协议都能实现相同的目标，因此你可以选择其中一种进行实现（就像你可以选择距离矢量或链路状态协议一样，但不能同时选择两者）。



![img](https://textbook.cs168.io/assets/beyond-client-server/7-010-dvmrp-cbt-taxonomy.png)

## IGMP：直接连接的主机

在解决多播路由这个更大的问题之前，让我们先从一个更小的问题开始。假设一个路由器直接连接到许多主机。路由器需要某种方式来知道每个主机属于哪些组。我们将使用一种称为 IGMP（互联网组管理协议）的协议来实现这一点。

从高层次来看，路由器和主机交换消息，以便路由器了解每个人的组成员身份。可以交换的一些消息类型包括：

**查询（Queries）**：路由器定期向主机发送查询。这些消息会问：你属于哪些组？

**报告（Reports）**：作为响应，主机向路由器发送报告。报告回答了这个问题：这些是我所属的组。主机也可以发送主动报告（即不等待查询）。



![img](https://textbook.cs168.io/assets/beyond-client-server/7-011-igmp-queries-reports.png)

通过定期交换查询和报告，路由器能够了解最新的组成员身份。如果路由器很长时间没有收到关于某个成员身份的报告，它会认为该成员身份已过期并将其失效。

IGMP 帮助路由器了解直接连接的主机。然而，路由器仍然对网络中其他地方的主机一无所知，因此我们需要用于这些情况的路由算法。

与距离矢量路由相比，你可以将 IGMP 视为多播版本的静态路由，其中路由器了解其直接连接的主机（但不了解网络中其他地方的主机）。

> （注：文档部分内容可能由 AI 生成）