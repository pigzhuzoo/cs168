# BGP 的实现与问题

## 边界路由器和内部路由器

到目前为止，我们对 BGP 在自治系统（AS）之间的工作方式有了一个直观的认识。在本节中，我们将展示 BGP 在路由器层面的实际实现方式。在此过程中，我们还将展示 BGP 如何与之前介绍的域内路由协议进行交互。

到目前为止，我们的域间路由模型将整个 AS 视为一个单一实体，负责导入和导出路径。



![img](https://textbook.cs168.io/assets/routing/2-165-combining1.png)

然而，实际上，一个 AS 包含许多通过链路连接的路由器（和主机）。



![img](https://textbook.cs168.io/assets/routing/2-166-combining2.png)

为了实际实现 BGP，AS 内部的所有路由器需要协同工作，以充当一个单一节点。

在一个 AS 内部，我们将所有路由器分为两类。**边界路由器**至少有一条链路连接到其他 AS 的路由器。**内部路由器**的链路只连接到同一 AS 内的其他路由器。



![img](https://textbook.cs168.io/assets/routing/2-167-borders.png)

只有边界路由器需要向其他 AS 通告路由。有时，我们将通告 BGP 路由的路由器称为**BGP 发言者**。BGP 发言者需要理解 BGP 协议的语义和语法（如何读取和创建 BGP 通告、收到通告时该做什么等等）。

## 外部和内部 BGP 会话

**BGP 会话**由两台相互交换信息的路由器组成。



![img](https://textbook.cs168.io/assets/routing/2-168-bgp1.png)

**外部 BGP（eBGP）会话**存在于来自不同 AS 的两台路由器之间。eBGP 会话可用于在不同 AS 之间交换通告，以及学习到其他 AS 的路由。只有边界路由器参与 eBGP 会话（因为 eBGP 需要与其他 AS 进行通信）。



![img](https://textbook.cs168.io/assets/routing/2-169-bgp2.png)

相比之下，**内部 BGP（iBGP）会话**存在于同一 AS 内的两台路由器之间（不一定通过链路直接连接）。更具体地说，如果一台边界路由器学习到了一条新路由，它可以使用 iBGP 将该新路由分发给 AS 内的其他路由器。这使得 AS 内的所有路由器能够协同工作，共同作为一个实体。边界路由器和内部路由器都会参与 iBGP 会话。



![img](https://textbook.cs168.io/assets/routing/2-170-bgp3.png)

eBGP 和 iBGP 会话不同于**内部网关协议（IGP）**。IGP 是在 AS 内部部署的域内路由协议（如距离矢量协议、链路状态协议），用于在 AS 内部路由数据包。



![img](https://textbook.cs168.io/assets/routing/2-171-bgp4.png)

人们很容易混淆 iBGP 和 IGP。两者都在同一 AS 内交换消息。然而，iBGP 是域间协议的一部分，帮助路由器学习到其他 AS 的路径。IGP 是域内协议，帮助路由器学习到同一 AS 内目的地的路径。



![img](https://textbook.cs168.io/assets/routing/2-172-bgp5.png)

eBGP、iBGP 和 IGP 协同工作，以建立从互联网中任何一台路由器到另一台路由器的路由（即使这些路由器位于不同的 AS 中）。

首先，每个 AS 运行 IGP 以学习同一 AS 内任意两台路由器之间的最低成本路径。



![img](https://textbook.cs168.io/assets/routing/2-173-bgp6.png)

接着，各个 AS 运行 eBGP，相互通告路由，以学习到其他 AS 的路由。



![img](https://textbook.cs168.io/assets/routing/2-174-bgp7.png)

最后，各个 AS 运行 iBGP，以便学习到外部路由的路由器能够将该路由分发给同一 AS 内的所有其他路由器。



![img](https://textbook.cs168.io/assets/routing/2-175-bgp8.png)

从 eBGP、iBGP 和 IGP 学到的路由可用于将数据包发送到互联网的任何地方。如果目的地在同一 AS 内（相同的 IP 前缀），我们可以使用从 IGP 学到的路由转发数据包。如果目的地在不同的 AS 内（不同的 IP 前缀），我们可以借助 iBGP，它会告诉我们本 AS 内任何设备发现的外部路由。利用 iBGP 的结果，我们可以确定哪台边界路由器位于该外部路由上。然后，我们可以使用 IGP 将数据包转发到正确的边界路由器（该边界路由器随后会将数据包转发到下一个 AS）。



![img](https://textbook.cs168.io/assets/routing/2-176-bgp9.png)

举一个具体的例子，假设 E 想要向 Z 发送数据包。首先，E 所在 AS 内的每个路由器都运行 IGP，学习所有内部路由。接着，AS#5 中的某个路由器使用 eBGP 通告一条到 Z 的路由。此时，只有 G 知道它可以到达 Z。最后，G 使用 iBGP 告诉其所在 AS 内的所有路由器它可以到达 Z。

E 通过 iBGP 得知，同一 AS 内的路由器 G 可以到达 Z。利用 IGP 路由，E 可以将数据包发送到 G（首先转发给 F）。然后，G 可以使用通过 eBGP 学到的路由将数据包发送到 Z。

通告到外部目的地路由的边界路由器有时被称为该目的地的**出口路由器**。这是能够帮助你的数据包离开本地网络并前往更接近目的地的其他网络的路由器。在上面的例子中，G 是目的地 Z 的出口路由器。

这些协议的一个结果是，每个路由器都有两个转发表。一个是将所有内部目的地（同一 AS）映射到下一跳的表，由 IGP 提供信息填充。另一个是将所有外部目的地映射到出口路由器（知道到外部目的地路由的路由器）的表，由 eBGP 提供信息填充。



![img](https://textbook.cs168.io/assets/routing/2-177-bgp10.png)

请注意，在 eBGP 表中，出口路由器不一定是下一跳。出口路由器可能距离本地有几跳之远，但我们会使用 IGP 到达该出口路由器。



![img](https://textbook.cs168.io/assets/routing/2-178-bgp11.png)

我们已经了解了 eBGP（路径矢量，用于通告路由）和 IGP（距离矢量或链路状态）是如何作为算法实现的。iBGP 是如何实现的呢？当一台边界路由器安装了一条到某个目的地的新路由时，它必须通知 AS 内的其他路由器。一个简单的解决方案是让边界路由器直接告诉 AS 内的所有其他路由器。



![img](https://textbook.cs168.io/assets/routing/2-179-bgp12.png)

这个解决方案相对简单，但它要求每个边界路由器与其他所有路由器都建立 iBGP 会话。在一个有 B 台边界路由器和 N 台总路由器的网络中，该协议需要 BN 个 iBGP 连接，并且随着本地网络规模的扩大，其扩展性可能会很差。

注意：实际上，还有其他组合域间和域内路由器的方法。如果你感兴趣，可以查阅 “路由反射器”，不过本课程不会涉及。

## AS 之间的多链路：热土豆路由

到目前为止，在我们的 AS 图中，如果两个 AS 是相连的，我们会显示它们之间有一条链路（边）。实际上，由于一个 AS 实际上由许多路由器组成，两个 AS 之间可能通过多条链路连接。

在实践中，大型 AS 之间有多个链路是很有用的。例如，Verizon 和 AT\&T 是非常大的 AS，其基础设施遍布美国各地。假设这两个 AS 在西海岸只有一条链路。如果东海岸的一台 Verizon 路由器和东海岸的一台 AT\&T 路由器想要通信，数据包必须通过 Verizon 的网络横穿全国，通过这条链路进入 AT\&T 的网络，然后再横穿全国到达目的地。



![img](https://textbook.cs168.io/assets/routing/2-180-multilink1.png)

两个 AS 之间的多条链路也意味着，两台路由器之间可能有多条路径经过相同的 AS。在 AS 层面，这些路径都经过相同的 AS，我们之前的模型没有对它们进行区分。然而，在更详细的模型中，这些路径都需要被导出，并且需要选择一条优选路由进行导入。



![img](https://textbook.cs168.io/assets/routing/2-181-multilink2.png)

如果有两条路由，导入 AS 会选择哪条呢？



![img](https://textbook.cs168.io/assets/routing/2-182-multilink3.png)

带宽是有成本的，因此，我希望流量尽可能多地在他人拥有和付费的基础设施上传输，尽可能少地在自己的基础设施上传输。因此，橙色路径是更优的。

更正式地说，导入 AS 会收到两个通告：一个来自西部路由器，一个来自东部路由器。



![img](https://textbook.cs168.io/assets/routing/2-183-multilink4.png)

通过 iBGP，AS 内的每个路由器都会看到这两个通告。一个通告表示出口路由器是西部路由器，另一个表示出口路由器是东部路由器。每个路由器都必须决定导入哪个通告。



![img](https://textbook.cs168.io/assets/routing/2-184-multilink5.png)

让我们聚焦于路由器 E。利用 IGP，该路由器可以计算到西部出口路由器（F）的距离和到东部出口路由器（I）的距离。由于西部出口路由器（F）更近，通过西部出口路由器（F）路由数据包将消耗更少的本 AS 带宽。因此，该路由器会导入通过西部出口路由器（F）的路径。而另一台更靠近东部出口路由器（I）的路由器可能会选择导入另一条路径。



![img](https://textbook.cs168.io/assets/routing/2-185-multilink6.png)

这种选择最近出口路由器的策略有时被称为**热土豆路由**。我们希望数据包尽快离开我们的 AS，尽快开始在他人的链路上传输。

## 路由器之间的多链路：MED

如果一台路由器到两个可能的出口路由器的距离相等，该怎么办呢？



![img](https://textbook.cs168.io/assets/routing/2-186-med1.png)

为了打破平局，导出 AS 可以通告对某条路由的偏好。

导出 AS 会偏好哪条路由呢？同样，由于带宽有成本，导出 AS 更偏好粉色路径，因为它消耗的自身带宽更少。在粉色路径的通告中，导出 AS 可以额外说明 “我更希望你使用这条路径”，而在橙色路径的通告中，导出 AS 可以额外说明 “我更希望你避开这条路径”。



![img](https://textbook.cs168.io/assets/routing/2-187-med2.png)

现在，到两个出口路由器距离相等的路由器可以在 iBGP 通告中看到这个额外信息。



![img](https://textbook.cs168.io/assets/routing/2-188-med3.png)

利用这个额外信息，路由器可以选择粉色路径上的出口路由器，因为导出 AS 更偏好这条路径。



![img](https://textbook.cs168.io/assets/routing/2-189-med4.png)

导出通告中的这个额外信息被称为**多出口区分符（MED）**。从出口方的角度来看，它指示了我方希望对方进入我方网络的优选路由器。从进口方的角度来看，它指示了对方 AS 希望我方离开我方网络并进入对方 AS 网络的优选路由器。

对 MED 的另一种解释是，通过该路由器到目的地的距离。出口方可以说，“西海岸路由器到目的地有 3 跳”，“东海岸路由器到目的地有 12 跳”。MED 值越小越受偏好，因为出口方希望使用尽可能少的自身带宽。出口方更愿意使用 3 条自身链路，而不是 12 条。

## 导入策略优先级

我们的更详细模型（两个 AS 可以通过多条链路连接）意味着，除了高 - 雷福德规则（Gao-Rexford rules）之外，我们现在还有额外的导入策略规则。当收到针对同一目的地的多个通告时，按以下顺序根据这些平局打破规则选择路径：



1.  使用**高 - 雷福德规则**。优先选择客户通告的路径，其次是对等体通告的路径，最后是提供商通告的路径。

2.  如果多条路径具有相同的高 - 雷福德优先级（例如，两条路径都来自客户），选择**更短的路径**（经过更少 AS 的路径）。

3.  如果多条路径长度相同，选择**出口路由器更近**的路径（使用 IGP 计算到每个出口路由器的距离）。

4.  如果到出口路由器的距离相同，选择**MED 值更低**的路径（MED 包含在通告中）。

5.  如果多条路径的 MED 值相同，则**任意打破平局**（例如，选择 IP 地址更小的路由器）。



![img](https://textbook.cs168.io/assets/routing/2-190-med5.png)

请注意，最近出口路由器（热土豆路由）和 MED 通常是相互矛盾的。每个 AS 都希望最小化自身的带宽使用，并希望数据包在其他 AS 的带宽上传输。

作为导出 AS，我希望数据包进入我的 AS 时尽可能靠近目的地。这意味着我希望导入 AS 将数据包传输很远（到出口的路径很长）。



![img](https://textbook.cs168.io/assets/routing/2-191-med6.png)

相比之下，作为导入 AS，我希望尽可能少地传输数据包（到出口的路径很短）。这意味着我希望数据包进入其他 AS 时尽可能远离目的地（迫使其他 AS 承担所有工作）。



![img](https://textbook.cs168.io/assets/routing/2-192-med7.png)

这种矛盾的一个结果是，互联网中的路径通常是不对称的。如果两台主机来回发送数据包，一个方向的路径可能与另一个方向的路径不同。



![img](https://textbook.cs168.io/assets/routing/2-193-med8.png)

在这个例子中，对于东行数据包，A 选择西部出口路由器，迫使 B 承担大部分流量传输。而在相反（西行）方向，B 选择东部出口路由器，迫使 A 承担大部分流量传输。

从根本上说，BGP 允许这种行为，因为每个 AS 都有权设置自己的策略（在这里，该策略是热土豆路由）。

在实践中，有时 AS 会尝试实施更巧妙的策略，诱使其他 AS 传输更远的数据包。或者，带宽更好的 AS 可能会同意为你传输更远的流量，如果你支付额外费用的话。

## BGP 消息类型和路由属性

回想一下，一个协议必须指定语法和语义。具体来说，BGP 必须指定发送和接收的消息结构。BGP 还必须指定路由器收到消息时应该做什么。

有四种不同的 BGP 消息类型。打开（Open）消息可用于在两台路由器之间启动会话以进行通信。保活（KeepAlive）消息可用于确认会话仍然活跃，即使最近没有发送消息。通知（Notification）消息可用于处理错误。我们不会进一步详细描述这前三种消息类型。

我们将重点关注第四种也是最有趣的消息类型：更新（Update）。这些消息用于通告新路由、更改现有路由或删除不再活跃的路由。

更新消息包含一个目的地，以 IP 前缀表示。该消息还包含**路由属性**，可用于编码与该 IP 前缀对应的任何有用信息。路由属性是一组名值对，其中名称表示属性类型，值表示该属性的值。一个非网络领域的属性示例可能是：color=red，shape=triangle。属性名称是 color 和 shape，它们对应的值分别是 red 和 triangle。

有些属性是 AS 本地的，仅在 iBGP 消息中交换。其他属性是全局的，可以在 eBGP 通告中发送。

BGP 有许多属性，但我们将重点关注三个重要属性，它们用于编码导入路径的不同平局打破规则。

**本地优先级（LOCAL PREFERENCE）** 属性在特定 AS 内部编码高 - 雷福德导入规则（最高优先级的平局打破规则）。一个 AS 可以为更优的路由（例如来自客户的路由）分配更高的值，为较次的路由（例如来自提供商的路由）分配更低的值。该属性是本地的，仅在 iBGP 消息中携带。该属性不会在 eBGP 通告中发送给其他 AS，因为其他 AS 不需要知道本 AS 的偏好。



![img](https://textbook.cs168.io/assets/routing/2-194-attribute1.png)

例如，假设路由器 E 从 AS#7 收到一条 eBGP 通告，并且路由器 A 知道 AS#7 是客户。然后，在 iBGP 消息中，路由器 E 可以设置本地优先级值为 3000（高数值）。现在，同一 AS 内的所有其他路由器都知道，路由器 E 可以通过 ASPATH 属性中的路径到达它所通告的目的地，且本地优先级为 3000。

相比之下，如果路由器 D 从 AS#79 收到一条 eBGP 通告，而该 AS 是对等体，那么在 iBGP 消息中，路由器 D 可以设置较低的本地优先级值为 1000，然后将这条路径（具有较低的本地优先级）分发给 AS 内的其他路由器。

本地优先级数值是任意的，只有它们的相对排名才重要。在上面的例子中，这些数值可以是 300 和 100，而不是 3000 和 1000，行为是相同的。本地优先级数值通常由运营商手动设置。

**AS 路径（ASPATH）** 属性包含所通告路由经过的 AS 列表（按反向顺序）。该属性是全局的，可以在 eBGP 通告中发送。



![img](https://textbook.cs168.io/assets/routing/2-195-attribute2.png)

例如，一条通告可能包含目的地的 IP 前缀（128.112.0.0/16），以及 ASPATH 属性 \[3, 72, 25]。

ASPATH 是导入路径时的第二优先级平局打破规则。如果两条通告具有相同的本地优先级（例如，都来自客户），那么我们将选择更短的路径。ASPATH 告诉我们每条路径的长度，以路径经过的 AS 数量来衡量。

如果本地优先级和路径长度相同，第三优先级的平局打破规则是到出口路由器的 IGP 成本。该成本存储在路由器的本地转发表中（例如，本地距离矢量协议会存储到同一 AS 内每个其他路由器的成本）。

**MED** 属性编码导出 AS 的偏好。同样，该属性表示从导出路由器到目的地的距离（数值越小越受偏好）。



![img](https://textbook.cs168.io/assets/routing/2-196-attribute3.png)

例如，如果这两个 AS 之间有两条链路，导出 AS 的两个边界路由器都会通告一条路径。由于到目的地的 AS 路径相同，因此 ASPATH 和目的地是相同的。然而，西部路由器会包含比东部路由器更低的 MED 属性值。这表示：在可能的情况下，请通过我的西部路由器（数值更低）路由到该目的地的数据包，因为该路由器更靠近目的地。

如果本地优先级、路径长度和到出口路由器的距离都相同，第四优先级的平局打破规则是每条通告中的 MED 数值。

## BGP 的问题

BGP 没有内置的安全保障。恶意 AS 可能会撒谎，通告到某个目的地的路由，即使该 AS 无法到达该目的地。恶意 AS 也可能通告到某个目的地的一条非常 “便宜” 的路由，即使这条便宜的路由实际上并不存在。这可能会促使其他 AS 通过该恶意 AS 路由数据包，而攻击者可以删除或修改经过该恶意 AS 的数据包。这些攻击被称为**前缀劫持**。目前有关于使用加密技术来保护 BGP 的积极研究，但此类协议尚未广泛部署。

BGP 在选择路径时优先考虑策略而非最低成本。此外，由于 BGP 以 AS 数量来衡量路径长度，路径长度可能会产生误导（例如，一条路径中的某个 AS 可能包含 2 台路由器，也可能包含 200 台路由器）。这可能导致数据包并不总是走最低成本路径，并且难以推断互联网上的性能。有些人可能将这些视为问题，尽管它们更可能是有意的设计权衡。BGP 的设计者有意识地做出了优先考虑策略并隐藏 AS 内部拓扑结构的设计选择，为此牺牲了性能。

BGP 的实现很复杂。有许多我们没有涵盖的微妙实现细节。即使在我们涵盖的主题中，像本地优先级或 MED 数值这样的某些配置也必须由运营商手动设置，错误的配置可能导致错误的路径在网络中传播。BGP 配置错误经常会导致互联网中断，目前有关于验证 BGP 是否正确配置的工具的积极研究。

BGP 需要某些假设（所有 AS 都遵循高 - 雷福德规则、AS 图形成层次结构、没有提供商 - 客户循环）才能保证可达性和收敛性。如果这些假设不成立（例如，某个 AS 选择违反高 - 雷福德规则的自身策略），BGP 可能会产生不稳定的行为，导致路由永不收敛，或者出现循环和死胡同。

> （注：文档部分内容可能由 AI 生成）