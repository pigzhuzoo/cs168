# 地址编址

## 路由的可扩展性

到目前为止，我们的转发表中每个目的地都有一个条目。但这在整个互联网范围内是无法扩展的。

如果我们在整个互联网上运行距离向量算法，就必须为互联网上的每台主机发送通告。如果运行链路状态算法，每个路由器都必须知道完整的互联网网络拓扑图。在这两种情况下，只要有主机加入或离开互联网，我们就必须重新计算以收敛到新的路由状态。

路由实现可扩展的关键在于主机的编址方式。到目前为止，我们用一些名称（如 R1、R2、A、B）来称呼每台主机和路由器，但在实际中，我们会使用更智能的编址方案。



![img](https://textbook.cs168.io/assets/routing/2-099-scaling-routing.png)

## IP 编址

回想一下我们的邮政服务类比，在不同场景下有不同的编址方案。邮递员使用街道地址，比如赫斯特大道 2551 号。大楼里的秘书使用房间号，比如索达堂 413 室。地址的分配具有一定的结构性。例如，所有三楼的房间号都以数字 3 开头，所有四楼的房间号都以数字 4 开头。

就像邮政系统一样，互联网在每一层都使用不同的编址方案。在本节中，我们将重点介绍 IP 地址，它可用于第三层的路由。

网络上的每台主机（例如你的电脑、谷歌的服务器）都被分配了一个 IP 地址。在本节中，你可以假设每台主机都有一个唯一的 IP 地址。

**IP 地址**是一个唯一标识主机的数字。就像邮政系统一样，这个数字包含了主机所在位置的相关信息。

需要注意的是，IP 地址不一定是静态的。在上述类比中，如果你搬到另一个房子，你的地址会改变。同样，如果你的电脑移动到不同的位置，当它加入网络时可能会被分配一个不同的 IP 地址（而你的旧 IP 地址最终会失效）。

IP 地址的长度取决于所使用的 IP 版本。IPv4 地址是 32 位的，IPv6 地址是 128 位的。这两个版本的路由概念相似，但我们会尽可能使用 IPv4，因为较短的地址更易读。

## 层次化编址

回想一下，互联网是一个由多个网络组成的网络。存在许多本地网络，我们通过在本地网络之间添加链路来形成更广泛的互联网。这为我们提供了一个天然的层次结构，可用于组织编址方案。



![img](https://textbook.cs168.io/assets/routing/2-100-address-intuition1.png)

这是一个直观的编址示意图。我们可以给每个网络分配一个编号。然后，在网络 3 中，我们可以给主机分配编号 3.1、3.2、3.3 等，其他网络中的主机也是如此。



![img](https://textbook.cs168.io/assets/routing/2-101-address-intuition2.png)

现在，考虑路由器 R9 中的转发表。以前，我们需要为网络 1 中的每台主机都设置一个条目，且它们的下一跳都是 R6。有了层次化编址，我们可以用一个条目来表示整个本地网络，即所有 1.*地址（其中*代表任意数字）的下一跳都是 R6。我们也可以表示所有 2.\* 地址的下一跳都是 R8。

这种使用通配符匹配来汇总路由的层次化模型，能让我们的转发表更小。

此外，这种模型还能让我们的表更稳定。



![img](https://textbook.cs168.io/assets/routing/2-102-address-intuition3.png)

如果网络 1 内部的拓扑发生变化，我们不需要更新 R9 的转发表（或其他网络中的任何表）。实际上，本地网络内部的变化（如新增主机加入网络）比网络之间的变化（如铺设新的地下电缆）频繁得多，因此本地变化只影响本地表是一件好事。

更一般地说，我们的地址有两个部分：网络 ID 和主机 ID。这使得域间路由协议可以专注于网络 ID 来寻找网络之间的路由，而域内路由协议可以专注于主机 ID 来寻找网络内部的路由。这也让我们的路由协议在网络发生变化时更稳定。域间协议不关心网络内部的变化，域内协议也不关心其他网络的变化。



![img](https://textbook.cs168.io/assets/routing/2-103-address-intuition4.png)

注意，R9 中的转发表仍然需要为其所在网络（即网络 2）内的每台主机设置条目。

同样，R4 是一台不连接其他网络的内部路由器，它既需要网络 3 内每台主机的条目，也需要其他网络的汇总条目（例如 2.\* 的下一跳是 R9）。转发表的规模取决于同一网络中的内部主机数量加上外部网络的数量。

## 默认路由

我们现在知道，表中的条目可以表示整个地址范围，而不总是单个地址。我们可以进一步扩展这个想法来提高可扩展性。



![img](https://textbook.cs168.io/assets/routing/2-104-aggregation1.png)

考虑 R4。它有每个外部网络（1.\*、3.*和 4.*）的条目，且下一跳都是 R9。我们可以将所有外部网络汇总成一个条目。我们仍然会有每个内部主机（2.1、2.2 等）的条目，但最后会加上：对于转发表中未包含的所有其他主机，下一跳是 R9。



![img](https://textbook.cs168.io/assets/routing/2-105-aggregation2.png)

我们可以在 R2 上使用更激进的汇总。同样，所有外部网络的下一跳都是 R3。但是，2.1、2.2、2.3、2.6 和 2.7 的下一跳也是 R3。因此，转发表只需要为 2.4 和 2.5 设置静态条目。然后，我们可以说，对于转发表中未包含的所有其他主机（包括一些内部和一些外部主机），下一跳是 R3。

为了表示表中未包含的所有主机，我们可以使用通配符 \*.*来匹配所有地址。当转发到某个目的地时，路由器首先检查特定主机（如 3.1）或范围（如 2.*）是否匹配。如果路由器找不到任何匹配项，最终会匹配 \*.\* 这个通配符。这被称为**默认路由**。

大多数主机只有一个硬编码的默认路由。例如，主机 2.4 的转发表有一个条目，即所有数据都发送到 R2。实际上，你的家用电脑有一个条目，即所有数据都发送到你的家用路由器。这就是主机不需要参与路由协议的原因。

## 分配层次化 IP 地址：早期互联网

为了实现更具可扩展性的路由，我们需要以某种层次化的方式分配地址。地址需要包含一些关于其位置的信息（例如，邻近的主机需要共享地址的某些部分）。

在早期的互联网中，IPv4 地址有一个 8 位的网络 ID 和一个 24 位的主机 ID，就像我们直观理解的那样。



![img](https://textbook.cs168.io/assets/routing/2-106-cidr1.png)

例如，AT\&T 的网络 ID 是 12，苹果公司的是 17，美国国防部有 13 个不同的网络 ID。

8 位的网络 ID 意味着我们只能分配 256 个不同的网络 ID，但在现实中，可能有远远超过 256 个的组织需要运营自己的本地网络。此外，24 位的主机 ID 意味着每个网络有 2^24 = 16,777,216 个地址。一个小型网络（例如，一个有 10 名员工的公司）可能不需要 1600 万个地址。随着互联网的发展，需要一种新的编址方法。

## 分配层次化 IP 地址：分类编址

第一次尝试解决这个问题的是**分类编址**，它根据需求分配不同大小的网络。在这种方法中，有 3 类地址，每类地址分配给网络 ID 和主机 ID 的位数不同。前 1-3 位用于标识地址类别。



![img](https://textbook.cs168.io/assets/routing/2-107-cidr2.png)

A 类地址以首位 0 开头。接下来的 7 位是网络 ID（128 个网络），再接下来的 24 位是主机 ID（1600 万台主机）。

B 类地址以首两位 10 开头。接下来的 14 位是网络 ID（16,000 个网络），再接下来的 16 位是主机 ID（65,000 台主机）。

C 类地址以首三位 110 开头。接下来的 21 位是网络 ID（200 万个网络），再接下来的 8 位是主机 ID（256 台主机）。

通过这种方法，我们现在可以有 200 万 + 16,000+128 个不同的本地网络。拥有更多主机的大型组织可以获得 A 类网络，小型组织可以获得 B 类或 C 类网络。和以前一样，在单个网络中，前几位的类别位和网络 ID 位是相同的，每个主机有不同的主机 ID。

分类编址的一个主要问题是每个类别的大小。A 类（1600 万台主机）对大多数组织来说太大了，而 C 类（256 台主机）对大多数组织来说又太小了。因此，大多数网络需要属于 B 类。

不幸的是，B 类网络 ID 只有 16,000 个，到 1994 年，我们已经快耗尽 B 类网络了。因此，又需要一种新的编址方法。

注意：分类编址在现代互联网中已不再使用。

注意：从技术上讲，每个网络的主机数量要少 2 个，因为全 0 地址和全 1 地址被保留用于特殊用途。例如，在 C 类中，实际上每个网络有 254 台主机，而不是 256 台。

## 分配层次化 IP 地址：CIDR

我们的第三种层次化编址方法，也是现代互联网仍在使用的方法，是**CIDR**（无类别域间路由）。在 CIDR 中，我们仍然有变长的网络 ID，但不再只有 3 种网络 ID 长度（A 类、B 类、C 类），而是可以任意指定固定位的数量。

例如，考虑前面提到的那个有 10 名员工的小公司。在分类编址中，他们会获得一个有 256 个主机地址的 C 类网络。如果他们只需要 10 个主机地址，我们可以通过给他们一个更长的网络 ID 来分配更少的地址。

如果我们分配一个 28 位的网络 ID，主机 ID 就是 4 位（16 个可能的地址）。如果分配一个 29 位的网络 ID，主机 ID 就是 3 位（8 个可能的地址）。我们无法精确分配 10 个地址，但 28 位的网络 ID 足以满足该公司的需求。虽然会有一点浪费（6 个未使用的地址），但这比分配 256 个地址要好得多。

再举一个例子，考虑一个需要 450 个主机地址的组织。在分类编址中，C 类（256 个地址）不够用，所以他们会获得一个有 65,000 个主机地址的 B 类网络，而大多数地址会被浪费。有了任意长度的网络 ID，我们可以分配一个 23 位的网络 ID，这样主机地址就有 9 位（512 个地址）。这满足了该组织的需求，并且浪费的地址要少得多。

## 多层级层次化分配

在现实中，层次结构可以是多层的。例如，在一个网络内部，一个组织可以选择将特定范围的地址分配给特定的子组织（如公司或大学的部门）。

实际上，我们利用现实中的多层组织和地理层次结构来分配地址。ICANN（互联网名称与数字地址分配机构）是拥有所有 IP 地址的全球组织。

ICANN 将地址块分配给代表特定国家或大陆的地区互联网注册机构（RIRs）。例如，RIPE 负责欧盟的所有地址，ARIN 负责北美的地址，APNIC 负责亚太地区的地址，LACNIC 负责南美的地址，AFRINIC 负责非洲的地址。例如：ICANN 将所有以 1101 开头的地址分配给 ARIN。

每个 RIR 再将其范围内的部分地址分配给大型组织（如公司、大学）或互联网服务提供商（ISPs）。这些组织或互联网服务提供商被称为本地互联网注册机构。例如：ARIN 控制所有以 1101 开头的地址，并将所有以 1101 11001 开头的地址分配给 AT\&T。

最后，每个本地互联网注册机构将 individual IPs 分配给特定的主机。为了增加层次，本地注册机构也可以将 IP 范围分配给小型组织，而小型组织又可以分配 individual IPs。



![img](https://textbook.cs168.io/assets/routing/2-108-cidr3.png)

在每个层级，额外固定的位数由要分配的地址数量决定。例如，ARIN 可能想给 AT\&T 800 万个地址，并计算出固定 9 位可以得到 800 万个主机地址。ARIN 已经固定了 4 位，所以再固定 5 位，并将所有以这 9 位开头的地址分配给 AT\&T。AT\&T 可能会将前缀 1101 11001 110100010 分配给加州大学伯克利分校，以提供 16,000 个地址。当我们将地址分配给子组织时，会固定更多的位，且始终保留父组织的固定位。

## 书写 IP 地址

我们可以将 IP 地址写成 32 位的 1 和 0 的序列，或者一个大整数。实际上，为了可读性，我们将每 8 位序列转换为一个整数（0 到 255 之间）。例如，IP 地址 00010001 00100010 10011110 00000101 可以写成 17.34.158.5。这有时被称为**点分四组**表示法。

到目前为止，我们一直在用位来表示地址范围（例如，所有以 1101 开头的 IP）。要表示地址范围，我们可以使用**斜线表示法**。我们写出固定前缀，然后将所有剩余的非固定位写成 0，将得到的 32 位值转换为点分四组 IP 地址。然后，在斜线后面写出固定位的数量。

例如，如果前缀是 11000000，我们将所有非固定位补 0，得到 11000000 00000000 00000000 00000000。作为 32 位地址，这是 192.0.0.0。由于固定了 8 位，我们将这个范围写成 192.0.0.0/8。

要将单个地址表示为一个范围，我们可以写成类似 192.168.1.1/32 的形式，表示所有 32 位都是固定的。此外，默认路由 \*.\* 可以写成 0.0.0.0/0。

斜线表示法有时看起来有点令人困惑，因为我们使用任意的 8 位划分并以十进制书写数字。例如，8 位前缀 11000000 和 12 位前缀 11000000 0000 会被写成 192.0.0.0/8 和 192.0.0.0/12（相同的 IP 地址表示不同的范围）。再举一个例子，如果我拥有 4 位前缀 1100，我可以分配 5 位前缀 11001。作为范围，它们被写成 192.0.0.0/4 和 200.0.0.0/5。乍一看，不清楚第二个范围实际上是第一个范围的子集，我们必须写出位才能确认。

斜线表示法中斜线（如 / 16）的替代方式是**子网掩码**。和斜线后面的数字一样，子网掩码告诉我们哪些位是固定的。要书写子网掩码，我们将所有固定位写成 1，非固定位写成 0，然后将结果转换为点分四组。例如，如果我们有范围 192.168.1.0/29，我们可以写成 29 个 1（固定位）和 3 个 0（非固定位）。11111111 11111111 11111111 11111000 作为点分四组是 255.255.255.248。子网掩码表示法中的范围是 192.168.1.0，子网掩码为 255.255.255.248（用子网掩码代替斜线）。

在这些笔记中，我们通常使用斜线表示法，因为它们更易于阅读。实际上，子网掩码很有用，因为给定一个特定的 IP 地址，如果你对 IP 地址和子网掩码执行按位与操作，所有主机位都会被置为 0，只留下网络位。

## 用 CIDR 汇总路由

在我们最初的具有网络 ID 和主机 ID 的模型中，我们可以将同一网络内的所有主机汇总到转发表中的一个路由条目（例如，用 2.\* 表示网络 2 中的所有主机）。

多层级层次化编址意味着我们也可以将多个网络汇总到一个路由中。



![img](https://textbook.cs168.io/assets/routing/2-109-aggregation1.png)

考虑这个网络 diagram。在我们最初的模型中，R6 需要为 AT\&T、加州大学伯克利分校（UCB）和斯坦福大学分别设置一个转发表条目。



![img](https://textbook.cs168.io/assets/routing/2-110-aggregation2.png)

然而，如果我们使用层次化编址，加州大学伯克利分校的范围（4.12.0.0/16）和斯坦福大学的范围（4.29.0.0/16）都是 AT\&T 范围（4.0.0.0/8）的子集。这可能是因为 AT\&T 将这些范围分配给了其下属客户加州大学伯克利分校和斯坦福大学。

现在，R6 只需要为 AT\&T、加州大学伯克利分校和斯坦福大学设置一个条目。我们已经将两个较小的范围汇总到了它们所属的更广泛的范围中。

## 多宿主

范围汇总并不总是可行的。假设我们添加了一条从 R6 直接到斯坦福大学的链路。



![img](https://textbook.cs168.io/assets/routing/2-111-aggregation3.png)

我们的汇总路由表示所有到 AT\&T（及其下属机构）的数据包的下一跳是 R2。我们需要添加一个额外的条目，说明到斯坦福大学的下一跳是 R7。

注意，我们的转发表现在有重叠的范围。一个目的地可能匹配多个范围。为了选择路由，我们会采用**最长前缀匹配**，即使用与目标 IP 地址匹配的最具体的范围。例如，如果我们有一个发往加州大学默塞德分校（UCM）主机的数据包，我们会使用加州大学默塞德分校的特定条目，因为它有更长的 19 位前缀。尽管 9 位的 AT\&T 条目也匹配该目的地，但它的前缀更短，所以我们不使用这条路由。

相反，如果我们有一个发往加州大学伯克利分校主机的数据包，我们不能使用斯坦福大学的特定条目，因为 16 位前缀与加州大学伯克利分校的主机不匹配。但我们仍然可以使用 8 位的 AT\&T 条目，它会匹配该目的地。

# IPv6 地址与发展

## IPv6 的简要历史

IPv4 地址是 32 位的，这意味着我们大约有 40 亿个可用地址。这足够吗？



![img](https://textbook.cs168.io/assets/routing/2-112-ipv6-1.png)

这张图表展示了各地区性注册机构随时间推移剩余未分配的 IP 地址数量（纵轴）。

到 2017 年，所有地区性注册机构可用的地址都不足一个 / 8 地址块（即少于 2²⁴=1600 万个地址）。每个地区性注册机构都预留了一个 / 8 地址块以备不时之需，但到 2017 年，所有机构都不得不开始使用这些备用地址。到 2021 年，就连备用地址也即将耗尽。

趣闻：2011 年 2 月，最后一个 / 8 地址块分配时还举行了一场线下仪式，甚至颁发了特殊的纸质证书。

随着互联网的发展，我们开始意识到地址最终会耗尽。幸运的是，人们很早就意识到了这一点，IPv6 于 1998 年被开发出来，以应对 IP 地址耗尽的问题。

从根本上讲，IPv6 的地址结构与 IPv4 相同。不过，IPv6 需要一些小的实现层面的改动，但这些与本文无关。

IPv6 的主要新特性是更长的地址。IPv6 地址是 128 位的，这意味着大约有 3.4×10³⁸个可能的地址。这是一个天文数字，所以我们永远不会用完。宇宙的年龄是 10²¹ 秒，即便我们每秒分配一个地址，也只用到了所有可用地址的 0.000000000000001%。



![img](https://textbook.cs168.io/assets/routing/2-113-ipv6-2.png)

IPv6 在 20 世纪 90 年代被开发出来，但并未立即被所有计算机采用。即便在 2010 年，基本上也没有人使用 IPv6。截至 2024 年，约 45% 的终端用户在使用 IPv6，其中大多数位于互联网普及率较高的发达国家。IPv6 之所以越来越普及，主要原因是我们正在耗尽 IPv4 地址。

为什么 IPv6 的采用速度如此缓慢？用户、服务器和互联网运营商必须升级他们的软件和硬件（例如路由器、链路、计算机上的设备驱动程序）以支持 IPv6。路由器现在需要两个转发表，一个用于 IPv4 地址，一个用于 IPv6 地址。

IPv6 的升级必须向后兼容。如果一台服务器只有 IPv6 地址，那么只支持 IPv4 的旧计算机用户就无法使用这台服务器。IPv4 和 IPv6 本质上是相互独立的地址系统，两者之间无法转换。截至 2024 年，许多计算机仍然不支持 IPv6，因此许多服务需要同时支持 IPv4 和 IPv6。

同时支持 IPv4 和 IPv6 的计算机还需要考虑使用哪一个。其中一个更好吗？实际上，IPv6 更快，但许多其他实现细节可能会影响选择。

## IPv6 地址表示法

IPv6 地址通常用十六进制而不是十进制表示。例如：

2001:0D08:CAFE:BEEF:DEAD:1234:5678:9012

这就是一个 IPv6 地址（32 个十六进制数字 = 128 位）。为了可读性，我们在每 4 个十六进制数字（16 位）之间添加冒号。

为了可读性，我们可以省略每个 4 位块中的前导零。例如：

2001:0DB8:0000:0000:0000:0000:0000:0001

可以简写为 2001:DB8:0:0:0:0:0:1。

为了可读性，我们还可以省略一长串零，例如 2001:DB8::1。双冒号表示用 0000 填充所有缺失的 4 位块。每个地址中只能这样做一次（省略两个零段会产生歧义，因为我们无法知道每个段中应该填充多少个零）。

斜线表示法在 IPv6 中仍然可以使用。单个地址的表示为 / 128（所有位均固定）。一个 32 位前缀可能看起来像 2001:0DB8::/32。

由于地址空间非常大，在 IPv6 中，我们可以将网络标识固定为 64 位，主机标识固定为 64 位，而且永远不会耗尽网络标识或主机标识。实际上，存在一些特殊协议，网络和主机可以通过这些协议自行选择 64 位的网络标识和主机标识（并检查没有其他设备在使用它们），而无需组织分配特定的标识。

实际上，地区性注册机构通常会向互联网服务提供商（ISPs）分配 32 位前缀，互联网服务提供商则通常会向组织分配 48 位前缀。组织随后可以向更小的子网分配 64 位前缀。在 IPv6 中，我们通常不会看到长于 / 64 的前缀。即便是组织内部最小的子网也有 64 位前缀和 64 位用于标识特定主机的位。使用这些标准化的前缀长度可以使前缀更具信息性。例如，在 IPv6 中，/19 前缀代表什么并不明确，但我们知道 / 32 前缀通常代表一个互联网服务提供商。（待确认）
