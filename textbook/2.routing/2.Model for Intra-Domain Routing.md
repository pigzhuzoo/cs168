# 域内路由模型

## 将网络建模为图

让我们创建一个简化的互联网模型，以帮助我们正式定义路由问题。

回想上一单元的内容，我们可以将互联网视为一组机器，通过一组链路连接在一起，其中每条链路连接网络上的两台机器。



![img](https://textbook.cs168.io/assets/routing/2-002-network-of-networks.png)

我们可以将网络拓扑表示为一个图，其中每个节点代表一台机器，两个节点之间的每条边代表两台机器之间的链路。

历史上，有时链路可以连接两台以上的机器，但在现代网络中，链路基本上总是恰好连接两台机器。

## 全 Mesh 网络拓扑

假设我们有两台机器 A 和 B。如果这两台机器想要交换消息，我们可以在它们之间添加一条链路。

但如果我们有五台机器而不是两台呢？一种可能的方法是在每对机器之间创建一条链路，使得每台机器都与其他所有机器相连。这有时被称为全 mesh 拓扑。



![img](https://textbook.cs168.io/assets/routing/2-005-mesh.png)

这种方法有哪些缺点呢？

这种方法的扩展性不好。如果我们试图将其扩展到现代互联网的规模，我们需要一根线连接世界上的每一对计算机。当一台新计算机加入网络时，我们需要在这台新计算机和世界上其他所有计算机之间创建新的链路。

尽管它无法扩展到整个互联网，但在较小的环境中，全 mesh 拓扑仍然有一些好处。特别是，在每对机器之间建立链路为网络提供了大量带宽。每台机器都有一条到所有其他机器的专用链路，每对机器都可以使用其专用链路上的全部带宽。

一般来说，不能保证每台机器都有到所有其他链路的直接链路。换句话说，不能保证底层图是完全连通的。

## 单链路网络拓扑

除了全 mesh 拓扑之外，还有其他方法可以部署链路来连接多台机器。例如，我们可以使用单条链路连接所有五台机器：



![img](https://textbook.cs168.io/assets/routing/2-006-single-link.png)

（在这里，我们暂时打破了链路只连接两台机器的假设，考虑一条连接两台以上机器的链路。）

这种方法比全 mesh 拓扑的扩展性更好。例如，如果一台新计算机加入网络，我们不必在新计算机和五台现有计算机之间创建五条新链路，而只需将现有线路延伸到新计算机即可。

然而，这种方法在机器可用的带宽量方面更受限制。特别是，只有一条链路，所有五台机器都需要共享这条链路上的带宽。

为了创建更复杂的网络拓扑，我们需要引入路由器的概念。

## 路由器和终端主机

在我们的简化模型中，我们将每台机器分为两种类型。

**终端主机**是连接到互联网以发送和接收数据的机器。终端主机的例子包括个人计算机上的应用程序，例如网页浏览器。Web 服务器，例如接收 Google 搜索查询并返回搜索结果的 Google 网络服务器，也是终端主机。这些机器向其他目的地发送传出数据包，并且可能是传入数据包的最终目的地。然而，这些机器通常不接收和转发中间数据包（即具有某些不同最终目的地的数据包）。

相比之下，**路由器**是连接到互联网的机器，负责接收中间数据包并将其转发到更接近其最终目的地的地方。例如，考虑安装在家庭网络中的路由器，或者位于某个数据中心大楼中的路由器。这些机器通常不会自己创建和发送新的数据包，并且它们通常不是数据包的最终目的地。例如，在日常互联网使用中，你可能想要向 Google 网络服务器发送数据包以执行搜索，但你可能不需要直接向家庭路由器或数据中心发送消息。这些路由器将帮助你将数据包转发到 Google，但它们不是数据包的最终目的地。



![img](https://textbook.cs168.io/assets/routing/2-007-host-router.png)

根据网络设计，路由器可以是合法的目的地，但在本单元中，我们将忽略作为目的地的路由器。不过，请注意，路由器有可能作为源并自己发送新的数据包。

路由器有时也被称为交换机。路由器和交换机之间存在历史差异，但如今，这两个术语可以互换使用。在这些笔记中，我们将尽可能使用 “路由器”。

在我们的互联网图模型中，路由器作为通常连接到多个邻居的中间节点出现。终端主机作为通常连接到一个或多个路由器的节点出现。实际上，这些假设并不总是成立。

在这些笔记中，只要可能，我们总是将路由器画成正方形，将终端主机画成圆形。实际上，路由器有时用其他符号表示。例如，这是网络 diagrams 中常用的路由器符号：



![img](https://textbook.cs168.io/assets/routing/2-008-router-icon.png)

## 带路由器的网络拓扑

现在，除了终端主机之外，我们还有了路由器，我们可以创建更复杂的网络拓扑，如下所示：



![img](https://textbook.cs168.io/assets/routing/2-009-router-topology.png)

这种拓扑使我们能够结合全 mesh 和单链路拓扑的优点。特别是，这种拓扑比前面的全 mesh 拓扑使用更少的链路。此外，这种拓扑比前面的单链路拓扑具有更多的带宽。

这种拓扑对故障的鲁棒性也更强。如果一条链路出现故障，数据包可以通过网络中的不同路径传输，仍然可以到达目的地。



![img](https://textbook.cs168.io/assets/routing/2-010-different-path.png)

## 路由中的终端主机

请注意，终端主机通常不参与路由协议，因为它们不转发中间数据包。相反，终端主机通常通过单条链路连接到单个路由器。默认情况下，终端主机将所有传出消息发送到路由器，路由器将确定如何将数据包发送到其最终目的地。这种将所有内容发送到路由器的策略有时称为终端主机的**默认路由**。

在设计路由协议时，我们通常忽略终端主机，除非它们作为目的地（因为路由器需要弄清楚如何到达不同的目的地）。

## 数据包

回想上一单元的内容，当应用程序想要通过互联网发送数据时，应用程序会创建一个包含数据的数据包。当数据包被传递到较低层协议时，额外的首部会包裹在数据包周围，带有帮助数据包到达目的地的元数据。

在路由单元中，我们将考虑一个简化的模型，其中每个数据包都有一个带有元数据的首部和一个带有应用层数据的有效载荷。我们现在暂时忽略嵌套首部和多个层。

路由协议与应用层数据无关。无论用户试图发送图像、HTML 网页还是音频文件，从路由的角度来看，我们都有一系列的 0 和 1，我们需要一个协议将这些比特发送到它们的目的地。

在首部中，我们关心的主要元数据字段是目的地址。这告诉我们数据包的最终目的地。当路由器收到数据包时，路由器会读取首部中的元数据字段，以确定如何将数据包转发到其最终目的地。弄清楚将数据包发送到哪里的问题是我们在路由中需要解决的关键问题。



![img](https://textbook.cs168.io/assets/routing/2-011-header.png)

## 编址

我们如何在数据包头中写下数据包的目的地呢？我们需要某种方式对网络上的每台机器进行编址。换句话说，我们需要一个协议为网络上的每台机器分配一个地址。

本单元后面，我们将讨论可扩展的编址方法。现在，让我们为每台机器分配一个唯一的标签（例如，我们可以给三个路由器标记为 X、Y 和 Z），并将这些标签视为每个路由器的地址。这将允许我们分别考虑路由问题和编址问题。

此时，我们可以定义路由问题：当路由器收到数据包时，路由器如何知道将数据包转发到哪里，以使其最终到达最终目的地？

## 网络拓扑会变化

到目前为止，我们已经定义了路由问题，但还有一些实际考虑因素使路由问题变得困难。

如果互联网可以被绘制为一个固定不变的图，那么我们或许可以通过简单地查看图并计算通过图的路径来解决路由问题。

然而，网络拓扑是不断变化的。例如，链路可能在不可预测的时间发生故障。现在，数据包必须通过不同的路由发送才能到达目的地。

也可能会添加新的链路，从而创建在路由过程中可以考虑的额外路径。

我们设计的路由协议需要对这些不断变化的网络拓扑具有鲁棒性。

## 路由协议是分布式的

如果网络发生变化，我们或许可以通过更新我们的图然后计算通过新图的路径来解决路由问题。

使路由变得困难的另一个问题是，路由器本质上没有整个网络的全局鸟瞰图。例如，如果网络中其他地方的一条链路发生故障，所有路由器不可能自动知道这一点。作为路由协议的一部分，我们必须以某种方式将有关新网络拓扑的信息传播给路由器。



![img](https://textbook.cs168.io/assets/routing/2-012-non-global.png)

这导致路由协议通常是分布式协议。不是由单个中央 “智囊” 计算所有答案，而是每个路由器必须计算自己的那部分答案（可能没有网络拓扑的完整知识）。总体而言，每个路由器计算的答案必须形成路由问题的全局答案，使数据包能够到达其最终目的地。

路由协议的分布式特性也意味着我们必须考虑单个路由器发生故障的情况。如果有一台计算机在解决这个问题，而这台计算机崩溃并忘记了答案，我们可以简单地让这台计算机从头重新计算整个答案。然而，在分布式协议中，如果一个路由器崩溃并忘记了其部分答案，我们的协议需要有一种方法来帮助这个路由器从故障中恢复并重新学习其部分答案。

## 链路是尽力而为的

回想上一单元的内容，第 3 层及以下的协议是尽力而为的。换句话说，当数据包通过链路发送时，不能保证数据包到达目的地。链路可能会丢弃数据包。

在设计路由协议时，我们也需要考虑这个问题。

> （注：文档部分内容可能由 AI 生成）