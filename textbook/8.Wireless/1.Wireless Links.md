# 无线链路

## 无线技术简介

无线通信技术实际上早于互联网出现。19 世纪 80 年代，光电话（贝尔和泰纳特发明）尝试利用光束无线传输数据。19 世纪 90 年代，无线电报（马可尼发明）尝试通过无线电波传输数据。同样在 19 世纪 90 年代，人们就进行了毫米波实验（博斯），而如今，毫米波再次成为研究的活跃领域。

从概念上讲，你可能会想象无线通信是由无形的粒子沿着从 A 点到 B 点的假想链路传播构成，但这其实并不太准确。实际上，无线通信更像是池塘上的涟漪。当你无线传输数据时，你会产生向外传播的涟漪，并且随着距离的增加而减弱。如果其他人也在传输数据，这些涟漪可能会相互产生建设性或破坏性的干扰。涟漪还可能在池塘上的船只等物体或池塘边缘发生反射或折射。



![img](https://textbook.cs168.io/assets/wireless/8-001-wireless-intro.png)

在本节中，我们将探讨有线通信和无线通信之间的四个关键区别。这些区别主要影响第 1 层（物理层）和第 2 层（链路层），不过也有一些例外情况我们稍后会讨论（特别是打破端到端原则并在第 2 层实现可靠性以提高性能）。

区别 1：无线本质上是共享介质，而有线不是。

区别 2：无线信号随距离增加而显著减弱，有线信号则不会。

区别 3：无线环境变化迅速，有线环境则相对稳定。

区别 4：在无线系统中，数据包冲突更难检测。

## 区别：无线是共享介质

区别 1：无线本质上是共享介质，而有线不是。

有线链路默认是专用的（点对点）。直观地说，一根导线连接两个设备。创建一个多点总线（即单根导线连接多个设备）需要额外的工作。外部信号很难干扰导线上的信号（例如，我们可以在导线外包裹屏蔽层）。在导线上，我们使用电信号传输数据（例如，高电压表示 1，低电压表示 0）。

无线链路则具有相反的特性。默认情况下，无线链路是共享的。直观地说，如果你传输一个信号，这个信号会向各个方向辐射。在两个主机之间创建专用的点对点链路需要额外的工作。很难屏蔽信号免受外部干扰。无线链路不是使用电信号，而是通过无线电波对二进制位进行编码来传输数据。

## 无线链路上的数据编码

在第 1 层，我们如何将数据编码到电磁波中？我们可以直接将二进制位序列（1 和 0）绘制成波形，但这样得到的波形可能是低频的，而事实证明低频信号很弱，难以传输。



![img](https://textbook.cs168.io/assets/wireless/8-002-modulation1.png)

相反，我们必须使用**调制**来传输数据。我们从载波信号开始，它只是一个恒定频率的波（例如正弦波）。这个波不携带任何信息，但它是高频的，因此更容易传输。然后，我们将数据信号（也称为调制信号）叠加到载波信号上。得到的波形是高频的（易于传输），同时也包含了我们要发送的数据！需要注意的是，接收器需要接收调制后的波形，并从中重新提取出 1 和 0。

有几种将数据信号调制到载波信号上的策略。在幅度调制（AM）中，我们根据输入信号改变载波信号的幅度。传输 1 时，让正弦波变高；传输 0 时，让正弦波变低。在频率调制（FM）中，我们根据输入信号改变载波信号的频率（宽度）。传输 1 时，让正弦波变窄（更高频率）；传输 0 时，让正弦波变宽（更低频率）。还有其他更复杂的调制策略，如相位调制，或幅度和相位结合的调制。



![img](https://textbook.cs168.io/assets/wireless/8-003-modulation2.png)

## 噪声与干扰

由于无线是共享介质，我们需要处理可能会破坏接收信号的噪声和干扰。即使附近没有其他设备在传输数据，噪声也始终存在。（打个比方，即使你周围没有人说话，自然界也会有环境噪声。）这种环境背景噪声被称为噪声底。相比之下，干扰指的是其他发射器有意发送的、会干扰我们信号的信号。

**SINR（信号与干扰加噪声比）** 是我们可以用来衡量接收器处无线连接质量的指标。顾名思义，SINR 是信号功率除以干扰功率与噪声功率之和。

SINR = 信号功率 /（干扰功率 + 噪声功率）

SINR 是一个无量纲的量，因为它是两个数值的比值。它也可以用分贝（dB）表示，分贝是一种用于测量比值的对数方式。0 dB 时，比值为 1；当 SINR 增加 10 dB 时，实际比值变为原来的 10 倍（例如，信号强度变为原来的 10 倍，或者噪声 / 干扰强度变为原来的 1/10）。



![img](https://textbook.cs168.io/assets/wireless/8-004-decibels.png)

SINR（dB）= 10・log₁₀（信号功率 /（干扰功率 + 噪声功率））

这个公式告诉我们什么？它告诉我们，如果噪声更大，我们就必须以更大的功率传输信号。我们也可以采用编码增益（可以理解为纠错码），这样即使信号很弱并混入了噪声和干扰，我们发送的信号也有足够的冗余度，使接收器能够重新提取出信号。

香农容量为我们提供了在给定信道上的噪声和干扰情况下，单位时间内可以传输的数据量的理论极限。这个公式不仅适用于无线链路，也适用于其他类型的链路（例如有线链路）。

C = B·log₂(1 + SINR)

在这个公式中，B 是信道的带宽。SINR 是信号与干扰加噪声比。C 是该信道单位时间内可以传输的数据量的理论极限，单位为比特每秒。需要注意的是，在这个公式中，带宽是指接收器所能理解的最高频率和最低频率之间的差值。

这个公式告诉我们什么？它告诉我们，随着带宽的增加，我们单位时间内可以传输更多的数据。它还告诉我们，随着 SINR 的增加（信号更强或噪声更少），我们单位时间内可以传输更多的数据。如果我们需要一个具有特定目标容量的链路（例如 1 Mbps），我们可以将链路的物理特性代入这个公式，看看我们的链路是否能满足期望的容量。

举个例子，考虑传统的电话系统。这个系统的带宽为 3 kHz，这意味着电话可以理解 300 Hz 到 3300 Hz 之间的频率。此外，这个系统的 SINR 大约为 20 dB，这相当于比值为 100（0 dB = 1 倍，10 dB = 10 倍，20 dB = 100 倍，30 dB = 1000 倍等）。将这些值代入公式，我们得到 C = 4000・log₂(1 + 100)≈20000，这表明电话系统大约可以传输 20 kbps（千比特每秒）的数据。

## 区别：衰减

无线信号随距离增加而显著减弱。相比之下，有线信号虽然也会随距离略有减弱，但影响要小得多。在无线系统中，我们的设计必须考虑信号衰减，而在有线系统中，衰减通常不是设计的关键考虑因素。

这就导致了无线系统设计中的一个基本权衡。我们希望通过提高链路的准确性、速度和传输距离来最大化性能。但同时，我们也希望通过节省能源（例如笔记本电脑的电量）和减少频谱使用（预留频谱可能成本很高）来最小化资源消耗。不幸的是，更好的信号需要更大的功率或更宽的频率带宽。

## 自由空间模型

一种简单的信号衰减建模方法是自由空间模型（也称为视距模型），在这种模型中，我们假设发射器和接收器处于完全空旷的环境中。信号向各个方向辐射，没有障碍物（甚至没有地球表面）。

在这个模型中，信号功率与发射器和接收器之间的距离成反比。这是由于平方反比定律：

Pr ∝ Pt / d²

在这个公式中，Pr 是接收器处的功率，Pt 是发射器处的功率，d 是发射器和接收器之间的距离。如果距离加倍，接收器处的信号强度将变为原来的 1/4。如果距离变为原来的 10 倍，接收器处的信号强度将变为原来的 1/100。



![img](https://textbook.cs168.io/assets/wireless/8-005-freespace1.png)

直观地说，平方反比定律在这里适用是因为信号向各个方向辐射。在任何时刻，信号都辐射到发射器周围的一个球体上，并且随着信号的进一步辐射，这个球体不断扩大。半径为 r 的球体表面积是 4πr²，因此随着信号的传播，它会扩散到一个面积随距离的平方增长的区域。例如，当距离加倍时，形成的球体表面积是原来的 4 倍。因此，信号扩散到的面积是原来的 4 倍，所以信号强度是原来的 1/4。



![img](https://textbook.cs168.io/assets/wireless/8-006-freespace2.png)

除了距离之外，我们还需要考虑发射器和接收器使用的天线。这就引出了用于测量远距离信号强度的弗里斯方程：

Pr = Pt·Gt·Gr·(λ²/(4π))·(1/(4πd²)) = Pt·Gt·Gr·(λ/(4πd))²

在这个公式中，和之前一样，Pr 是接收器处的功率，Pt 是发射器处的功率。Gt 是发射器的增益，Gr 是接收器的增益。λ 是波长，在这个公式中用来表示天线的面积。d 表示天线之间的距离。

这个公式告诉我们什么？要计算接收器处的信号强度，我们从发射器处的信号强度 Pt 开始。然后，乘以两个天线的增益 Gt 和 Gr。直观地说，增益越高，天线发送或接收信号的能力就越强。

正如我们之前看到的，距离根据平方反比定律影响信号强度，这就解释了 1/(4πd²) 这一项。

最后，λ²/(4π) 这一项与接收天线的孔径（可以理解为面积）有关。直观地说，如果你把光照射在一张纸上，光会照射到纸上。如果你使用更大的纸，更多的光会照射到纸上。天线的有效孔径（可以理解为面积）可以计算为 λ²/(4π)，不过这里我们不做证明。需要注意的是，公式中的 (4π)² 实际上来自两个 4π 因子，一个来自平方反比定律，另一个来自有效孔径方程。

我们也可以通过将等式两边除以 Pt 来重写弗里斯方程：

Pr/Pt = Gt·Gr·(λ/(4πd))²

这个公式告诉我们什么？接收器处的相对信号强度（例如，是发射器处信号强度的一半，还是 1/100）是天线增益、距离平方的倒数以及天线有效孔径（可以理解为面积）的函数。

弗里斯方程的另一种写法是对两边取对数，这样我们就可以用分贝来表示功率和增益：

Pr（dB）= Pt（dB）+ Gt（dB）+ Gr（dB）+ 20log₁₀(λ/(4πd))

自由空间模型是测量接收器处理想信号强度的有用理论模型，但在实际中，物理障碍物（例如地球表面）会阻碍我们达到这个理想值。

## 链路预算

如果信号随距离增加而减弱，我们如何知道一条链路是否真的能工作？换句话说，我们如何知道接收器是否能检测到可理解的信号？

为了衡量链路是否可行，我们可以计算链路预算，它考虑了链路上的所有增益和损耗。

Pr（dB）= Pt（dB）+ Σ 增益 - Σ 损耗

在这个公式中，Pr 是接收器处的信号功率，Pt 是发送器处的信号功率。所有增益（例如更强的天线增益）都会增加我们的链路预算，而所有损耗（例如长距离造成的路径损耗）都会消耗我们的链路预算。

将所有增益相加并减去所有损耗，就可以得到接收器处的信号强度。我们可以将其与接收器的灵敏度（即接收器提取有用信息所需的信号强度）进行比较。这种比较会告诉我们链路预算情况。如果总预算为正，那么这是一条可行的链路，我们是 “划算的”。如果总预算为负，那么这不是一条可行的链路，我们就 “有麻烦了”。

需要注意的是，链路预算是以分贝计算的，分贝是对数形式。这使得我们可以使用加减法而不是乘除法。例如，功率增加 1000 倍用增加 30 分贝表示，功率损耗到原来的 1% 用减少 20 分贝表示。



![img](https://textbook.cs168.io/assets/wireless/8-007-link-budget.png)

下面是一个计算链路预算的例子。发射器处的信号功率为 10 dB。信号通过一根电缆、一个避雷器（你不需要知道这是什么）和另一根电缆传输，沿途分别损耗 0.44 dB、0.1 dB 和 2.21 dB。然后，信号通过天线广播，这给我们带来 25 dB 的增益。接着，信号在 10 公里的空间中传输，损耗 120 dB。然后，信号被接收天线接收，带来 25 dB 的增益。之后，信号通过更多的电缆传输，分别损耗 0.44 dB、0.1 dB 和 2.21 dB，最终到达接收器。如果我们将所有增益相加并减去所有损耗，可以计算出接收器处的信号强度为 - 65.5 dB。

现在我们可以将这个信号强度与接收器灵敏度（-80 dB）进行比较。这表明接收器可以接收到任何高于 - 80 dB 的信号。由于 - 65.5 dB 高于 - 80 dB，我们的链路预算为正，这条链路应该可以工作！

**链路余量**是接收器处的信号强度与接收器灵敏度之间的差值。如果我们接收到 30 dB 的信号，而我们的灵敏度允许我们检测到任何超过 10 dB 的信号，那么我们的链路余量就是 20 dB。在前面的例子中，我们的链路余量是 14.5 dB。

链路余量告诉我们链路的质量。如果链路余量为负，链路将无法工作，信号也无法被接收。更高的链路余量是好的，因为这意味着我们的信号更可靠，对干扰和其他问题的抵抗力更强。

## 区别：环境变化

无线环境变化迅速。设备可能会移动。环境可能会发生变化（例如，一个物理障碍物移动到设备之间）。其他通信可能会开始干扰我们的通信。

在前面的自由空间模型中，我们将设备之间的距离 d 设为常数。但如果设备在移动呢？此外，我们假设环境中没有障碍物和干扰信号。在存在这些因素的情况下，我们的模型会发生什么变化？

在自由空间模型中，假设天线保持不变（相同的增益、相同的孔径），我们得到一个平滑的图表，其中信号强度随距离增加而降低。在考虑变化的环境后，得到的距离与信号强度的图表会更加不稳定。



![img](https://textbook.cs168.io/assets/wireless/8-008-obstacle1.png)

这个图表实际上是三个较小图表的总和。每个图表都显示了环境的不同特征如何作为距离的函数影响信号强度。请注意，有些特征随着距离的增加变化缓慢，而另一些则随着距离的增加快速且不规则地变化。



![img](https://textbook.cs168.io/assets/wireless/8-009-obstacle2.png)

第一个特征是自由空间路径损耗。我们已经从自由空间模型中看到，信号强度根据平方反比损耗随距离增加而缓慢且持续地降低。

第二个特征是阴影效应。当发射器和接收器之间的物理障碍物阻挡信号时，就会发生这种情况。信号必须折射或反射才能绕过障碍物，结果到达接收器的信号会更弱。

根据障碍物的位置，信号强度可能会随着距离的增加而变弱或变强。例如，如果我走到一栋建筑物前面，信号会变得弱很多，但如果我最终走过这栋建筑物，信号可能会再次变强。

第三个特征是多径衰落。当波在物理障碍物上反射和折射时，会导致信号的偏移版本到达接收器，这时就会发生多径衰落。特别是，如果信号通过不同长度的路径到达接收器，这些信号可能会相位不一致，从而导致干扰。

多径衰落会导致信号强度发生非常细微的变化。稍微改变距离可能会导致信号强度变强或变弱。

最终，如果我们想考虑这三个特征共同如何影响不同距离下的信号强度，我们必须查看这三个图表的总和。如果发送器和接收器保持静止，信号强度将是这个图表上的一个特定点。然而，如果设备在移动，那么信号强度会沿着这条曲线变化。此外，如果环境发生变化，障碍物出现或消失，那么图表本身也会发生变化。

## 路径损耗的近似

近似路径损耗（来自自由空间损耗、阴影效应和多径衰落）可能很困难。在存在障碍物导致信号通过多条路径传播，从而使相位不一致的信号在接收器处相互干扰的情况下，这一点尤其困难。

一种相对简单的路径损耗近似模型是**双射线模型**。在这个模型中，我们假设信号只沿着两条路径传播：一条是从发送器到接收器的直视路径，另一条是从地面反射到接收器的地面反射路径。请记住，这仍然是从发射器辐射的一个信号，但有些波直接到达接收器，而另一些则通过地面反射到达接收器。



![img](https://textbook.cs168.io/assets/wireless/8-010-obstacle3.png)

如果发送器和接收器相距足够远，两条路径的波将相差 180 度。结果，两条路径的波会产生相消干涉并相互抵消，从而显著削弱接收器处的信号。这时，信号强度不再与 1/d² 成正比，而是与 1/d⁴成正比。换句话说，随着距离的增加，信号强度下降得更快。

请记住，我们的自由空间模型假设没有障碍物（甚至没有地球表面），这就是为什么我们得出信号强度与 1/d² 成正比的原因。在双射线模型中，考虑到地球表面，信号强度现在与 1/d⁴成正比。



![img](https://textbook.cs168.io/assets/wireless/8-011-obstacle4.png)

如果除了地球表面之外还有其他障碍物呢？双射线模型没有考虑这些。在更复杂的环境中，我们可以创建通用的射线追踪模型，该模型考虑信号的反射、散射和衍射。这些模型需要环境的特定信息（例如障碍物的位置），并且可以通过计算机模拟来构建。在这些模型中，与未受阻碍的直视信号相比，信号的反射版本通常在信号中占主导地位。



![img](https://textbook.cs168.io/assets/wireless/8-012-obstacle5.png)

从这些模型中，我们可以推导出一个简化的路径损耗模型来关联距离和信号强度：

Pr = Pt·K / d^γ

在这个公式中，和之前一样，Pr 和 Pt 分别表示接收器信号功率和发射器信号功率，d 表示距离。

K 和 γ 是基于环境和模型的经验确定的常数。例如，如果存在许多位置不便的障碍物，K 可能会非常小，导致接收器信号强度较弱。

在实际中，γ 在 2 到 8 之间。在最佳情况下，信号强度与 1/d² 成正比，类似于自由空间模型。在最坏情况下，信号强度与 1/d⁸成正比，并且随着距离的增加，信号会减弱得更快。

## 区别：碰撞检测

有线环境中的碰撞通常很容易检测。在点对点链路上，碰撞可能根本不会发生。我们通常可以通过检测导线来发现碰撞。可能会有传播延迟的问题，但最终，导线上只有一个信号需要我们检测。

相比之下，无线环境中的碰撞更难检测，因为碰撞具有空间特性。波可能在一个地方发生碰撞，而在另一个地方则不会。



![img](https://textbook.cs168.io/assets/wireless/8-013-collision1.png)

在无线系统中，设计碰撞检测和碰撞避免要困难得多，但这仍然是必要的，以便多个设备可以在共享介质上发送数据。回想一下，多路访问有许多不同的方法，包括频率的固定分配，以及协调谁在什么时间发送。哪种方法最有效取决于具体环境。例如，如果你在偏远地区，可能可以容忍碰撞发生，然后在发生时再处理。不过，在本节中，我们将重点关注 CSMA（载波监听多路访问）方法，即先监听信号，如果有其他设备在发送就不传输。

在本节中，为简单起见，我们忽略障碍物，这意味着信号向各个方向辐射。我们假设信号在一定距离内保持全强度辐射，超过该距离后信号无法检测到。此外，在我们的示例中，为了简化，我们假设所有设备都排列在一条直线上，因此我们只需要考虑信号向左和向右传播。不过请记住，在现实生活中，信号是在三维空间中向外辐射的。

## CSMA 的问题

为了检查是否有其他设备在发送，无线电会尝试检测超过特定阈值的能量。如果检测到，我们就认为有其他设备在传输。

如果两对相距较远的设备在通信，这种策略效果很好。



![img](https://textbook.cs168.io/assets/wireless/8-014-collision2.png)

在这个例子中，A 和 B 想要通信，C 和 D 想要通信。A 没有检测到任何信号，开始向 B 传输。请注意，A 的信号向各个方向传播，不仅仅是向 B。之后，C 没有检测到任何信号（因为它在 A 的范围之外），所以它可以开始向 D 传输。

如果两对设备在彼此的范围内，这种策略也效果很好。



![img](https://textbook.cs168.io/assets/wireless/8-015-collision3.png)

同样，A 和 B 想要通信，C 和 D 想要通信。A 没有检测到任何信号，开始向 B 传输。之后，C 检测到信号，因为 A 在发送，而且 C 在该信号的范围内。因此，C 会等待 A 完成发送后，再开始向 D 传输。

有时，这种策略会导致问题。



![img](https://textbook.cs168.io/assets/wireless/8-016-collision4.png)

假设 A 和 C 都想和 B 通信。A 没有检测到任何信号，开始向 B 传输。之后，C 没有检测到任何信号，因为它在 A 的范围之外，所以 C 也开始向 B 传输。结果在 B 处发生了碰撞！

这被称为**隐藏终端问题**。在这种情况下，两个发射器（A 和 C）彼此不在对方的范围内，因此它们无法检测到正在进行的传输。

下面是 CSMA 存在问题的另一种情况：



![img](https://textbook.cs168.io/assets/wireless/8-017-collision5.png)

在这种情况下，假设 B 想要和 A 通信，C 想要和 D 通信。首先，B 没有检测到任何信号，开始向 A 传输。请记住，B 的信号向各个方向传播，包括向 C。现在，C 想要和 D 通信，但检测到 B 的信号，所以保持安静。

仔细想想，B 和 C 实际上可以同时传输。诚然，在 B 和 C 之间的空间会发生碰撞，但接收器（A 和 D）不会检测到任何碰撞。

这被称为**暴露终端问题**。在这种情况下，两次传输本可以同时进行，但由于 C 错误地检测到碰撞，其中一次传输被阻止了。

## 用于碰撞避免的 MACA

代替使用 CSMA，**MACA（带冲突避免的多路访问）** 是一种多路访问方法，将帮助我们解决隐藏终端问题。

CSMA 的关键问题是，发送器在发送端检测碰撞，但真正的问题是在接收端发生的碰撞。为了解决这个问题，我们将让接收器宣布它是否检测到任何碰撞。

假设 A 想要向 B 发送数据。一次成功的数据传输包括三个步骤：



![img](https://textbook.cs168.io/assets/wireless/8-018-maca1.png)



1.  A 传输一个**请求发送（RTS）** 数据包，其中包含数据的长度。这是 A 在说：“我想向 B 发送 k 位数据。”

2.  B 传输一个**允许发送（CTS）** 数据包，其中包含数据的长度。这告诉 A 可以安全发送，并确认接收端没有碰撞。CTS 还会警告 B 范围内的所有设备：“我是 B，我即将接收 k 位数据，所以在此期间请不要发送。”

3.  A 传输数据，B 接收数据。CTS 的警告确保了接收端范围内的所有其他设备在这段时间内保持安静。

这个协议解决了隐藏终端问题。回想一下，在隐藏终端问题中，A 和 C 都检测到信道空闲并开始传输，导致在 B 处发生碰撞。有了这个协议，如果 A 发送 RTS，B 会传输 CTS，警告 B 范围内的所有设备（包括 C）保持安静。



![img](https://textbook.cs168.io/assets/wireless/8-019-maca2.png)

如果你听到一个 RTS 数据包，这意味着你在发送器的范围内。发送器即将监听 CTS。因此，你需要保持安静并等待一个时间槽，这个时间槽足够长，以确保你不会用自己的数据干扰发送器接收 CTS。换句话说，你需要保持安静，让发送器能够接收到 CTS。

在 RTS 之后，如果你听到了 CTS，这意味着你也在接收端的范围内，所以在数据传输期间你必须保持安静。如果你没有听到 CTS，这意味着你在接收端的范围之外，你可以自己传输数据。

在某些假设下，这个协议解决了暴露终端问题。回想一下，在暴露终端问题中，B 正在向 A 发送数据，C 正在向 D 发送数据。使用 CSMA 时，C 检测到 B 的信号并保持安静，尽管它本可以安全传输。有了这个协议，如果 B 发送 RTS，C 会延迟一个时间槽（以避免干扰 B 接收 CTS）。然后，因为 C 没有听到 CTS，这意味着 C 在接收端（A）的范围之外，所以 C 可以安全地开始向 D 传输。



![img](https://textbook.cs168.io/assets/wireless/8-020-maca3.png)

我们要让这个协议生效的假设是，C 必须能够听到来自 D 的 CTS。请记住，即使 C 是发送器，它也必须在开始发送之前接收到 CTS。然而，C 实际上也在接收来自 B 的数据，所以它可能无法听到开始发送所需的 CTS。关键问题是：在 CSMA 中，发送器只负责发送。但在 MACA 中，发送器实际上必须在开始发送之前接收到 CTS，而在暴露终端情况下，这个 CTS 可能会被干扰。



![img](https://textbook.cs168.io/assets/wireless/8-021-maca4.png)

如果我们发送了一个 RTS，但没有听到相应的 CTS，这意味着我们不能发送。接收端发生了碰撞，可能是因为接收端正在接收数据，或者因为接收端同时收到了两个请求。如果发生这种情况，我们采用二进制指数退避（类似于 CSMA/CD），等待最长两倍的时间后再发送另一个 RTS。

在 MACA 中，每个设备都维护一个 CW（竞争窗口）值，它告诉我们在碰撞后应该等待多长时间再重新请求。如果我们检测到碰撞（没有 CTS），我们从 0 到 CW 之间选择一个随机数，等待该时间后再重新请求。最小值是 2 个时间槽，最大值是 64 个时间槽，其中一个时间槽是传输一个 RTS 所需的时间。在成功的 RTS/CTS 后，我们将竞争窗口重置回最小值 2。在失败的 RTS（没有 CTS）后，我们将竞争窗口加倍，但限制其不超过最大值 64。

## MACAW 特性：ACK（用于可靠性）

**MACAW（无线带冲突避免的多路访问）** 相对于 MACA 协议有一些改进。

第一个改进是添加确认以提高可靠性。和之前一样，发送器传输 RTS，接收器传输 CTS，发送器传输数据。现在，在最后多了一个步骤，即接收器传输一个确认（ack）。



![img](https://textbook.cs168.io/assets/wireless/8-022-macaw-acks.png)

如果数据丢失，那么就不会有确认，发送器将不得不重试，重新开始发送新的 RTS。如果数据正确发送但确认丢失，那么发送器将重新发送新的 RTS 进行重试，但接收器可以立即回复确认而不是 CTS。

我们为什么要添加确认？请记住，端到端原则指出，为了正确性，可靠性必须在终端主机上实现。然而，在这种情况下，我们在网络中沿着单条链路实现可靠性，纯粹是为了提高性能。如果我们不在链路上实现可靠性，TCP 仍然可以保证正确性，但丢失的数据包会导致 TCP 显著减速（回想一下，拥塞窗口会减半）。相比之下，通过在链路上实现可靠性，我们可以更有效地从数据包丢失中恢复。

## MACAW 特性：更好的退避（用于公平性）

当两个发生碰撞的主机想要发送数据时，MACA 协议是不公平的。特别是，赢家往往会一直赢，而输家往往会一直输。

下面是一个不公平的例子。假设 A 和 B 的窗口都设置为 2，它们同时尝试预留信道。假设 A 赢了，B 输了。然后 A 的窗口保持为 2，而 B 的窗口加倍到 4。这意味着 A 可能更快地再次预留信道，并且可能再次获胜。这也意味着当 B 再次尝试时，A 已经再次捕获了信道，B 的窗口再次加倍到 8。这种模式会持续下去，A 不断快速重新捕获信道，而 B 不断失败，并且在尝试（并失败）之前等待的时间越来越长。



![img](https://textbook.cs168.io/assets/wireless/8-023-maca-unfair.png)

为了解决这个问题，我们不让每个设备拥有自己的 CW，而是让所有设备共享同一个 CW。数据包头部现在包含一个 CW 值字段，如果你接收到一个数据包，你就将 CW 设置为该数据包中的值。由于现在所有设备都具有相同的 CW，重试机制不会偏袒任何一个设备。所有设备都从 0 到 CW 之间选择一个随机值，并等待该时间。（注意：这里我们做了一些简化，但如果所有设备都在彼此的范围内，情况确实如此。）

MACAW 还更改了 CW 更新规则，使其更加温和。和之前一样，最小值是 2，最大值是 64。在失败的 RTS（没有 CTS）时，我们将 CW 乘以 1.5（而不是加倍），并再次限制其不超过 64。在成功的 RTS/CTS/ 数据 / 确认传输后，我们将 CW 减 1（而不是直接重置为 2）。请注意，在成功的 RTS/CTS 但确认失败的情况下，CW 不会改变。这种方法有时被称为乘性增加、线性减少（MILD）。

## MACAW 特性：DS（用于暴露终端）

回想一下我们之前的暴露终端例子，B 想要与 A 通信。B 发送 RTS，A 发送 CTS，B 开始传输数据。此时，C 没有听到 CTS，这意味着 C 在接收端的范围之外，可以安全地传输数据。然而，为了传输，C 必须听到 CTS。但这可能不会发生，因为 C 也在接收来自 B 的数据，并且 B 的数据和 D 的 CTS 之间可能会发生碰撞。

MACAW 的结论是，在暴露终端情况下，B 到 A 和 C 到 D 实际上不能同时发送数据。是的，我们承认失败，事实证明 MACAW 和 CSMA 都无法解决暴露终端问题。

这意味着如果你在另一个发送器的范围内，你实际上不能发送数据（即使你不在另一个接收器的范围内）。重申一下，这是因为你会接收到来自另一个发送器的数据，这意味着你无法听到你开始发送所需的 CTS。

为了解决这个问题，我们在数据之前添加一个额外的数据发送（DS）数据包。这是发送器在警告所有设备：我即将发送 k 位数据，所以在此期间你需要保持安静。



![img](https://textbook.cs168.io/assets/wireless/8-024-ds1.png)

该协议现在有 5 个步骤：



1.  发送器传输 RTS，请求传输 k 位数据。

2.  接收器传输 CTS，告诉范围内的所有设备：保持安静，我正在接收 k 位数据。

3.  发送器传输 DS，告诉范围内的所有设备：保持安静，我正在发送 k 位数据。（其他设备不能发送数据，因为我的数据会干扰你接收传输所需的 CTS。）

4.  发送器传输数据。

5.  接收器传输确认。

请注意，RTS 和 DS 并不是多余的。RTS 是一个可能不会被批准的请求（例如，可能没有 CTS）。DS 确认请求实际上已被批准，并强制发送器范围内的所有设备必须保持安静。



## MACAW 特性：DS（用于同步）

DS 还有第二个重要用途。让我们再回顾一下暴露终端的情况，要知道 MACAW 会接受这种冲突情况，并强制两次传输分开进行。

假设没有 DS 分组。那么，和之前一样，B 发送 RTS（请求发送），A 发送 CTS（允许发送），然后 B 开始传输数据。C 听到了 RTS，会延迟一个时隙（以避免干扰 B）。但是，C 听不到 CTS。这时，C 注定会发送无用的 RTS，而且永远也听不到 CTS（因为它被 B 的数据淹没了）。C 会不断重试并发送无用的 RTS 请求，但它根本不知道 B 什么时候会停止发送数据。

相比之下，B 确切地知道自己什么时候会停止发送数据。这让 B 在接下来的竞争回合中拥有巨大优势。当 B 完成数据发送后，它可以立即发送另一个请求，而且很可能会获胜并继续发送数据。另一方面，C 不知道 B 什么时候会停止发送数据，所以它必须随机猜测何时发送下一个请求。大多数情况下，C 会在 B 仍在发送数据时猜测一个时间并重新请求，因此 C 会失败，请求也不会被允许（发生冲突）。



![img](https://textbook.cs168.io/assets/wireless/8-025-ds2.png)

这种缺乏同步的情况会导致不公平。如果我赢了，我很可能会再次赢，因为我确切知道下一轮竞争何时开始（就是我完成发送的时候）。如果你输了，你很可能会再次输，因为你不知道下一轮竞争何时开始（你不知道我什么时候结束）。竞争时间通常只是很小的一部分，因为大部分时间都用于发送数据。我确切知道那个时间点，而你不知道，所以我会一直赢。

DS 分组解决了这个问题，因为它允许发送方告诉所有人下一轮竞争何时开始。现在，B 通过 DS 分组告诉所有人：我要开始发送 k 位数据了。这样一来，C 不仅知道不要发送无用的 RTS 请求，还知道 B 什么时候会完成数据发送。这让 C 在接下来的竞争回合中有更公平的机会获胜。



![img](https://textbook.cs168.io/assets/wireless/8-026-ds3.png)

## MACAW 特性：RRTS（用于同步）

还有另一种情况，同步对于确保公平性至关重要。假设 A 想发送数据给 B，D 想发送数据给 C。

A 向 B 传输数据（A 发送 RTS，B 发送 CTS，A 发送 DS 并传输数据）。C 听到了 CTS，在数据传输期间必须保持安静。这时，D 就毫无头绪，注定会失败。D 会发送 RTS，但不会听到 CTS，因为 C 在保持安静。D 会在随机时间不断重试，而且会一直失败，因为它不知道 A 什么时候会停止发送数据。

相比之下，A 确切地知道自己什么时候会停止发送数据。和之前一样，这让 A 在接下来的竞争回合中拥有巨大优势。A 可以立即重新请求并获胜。另一方面，D 不知道何时重新请求。D 获胜的唯一可能是非常幸运，在 A 刚完成发送后、A 重新请求之前发送请求。



![img](https://textbook.cs168.io/assets/wireless/8-027-rrts1.png)

注意，DS 分组在这里帮不上忙，因为两个发送方 A 和 D 彼此不在对方的通信范围内。A 会发送 DS 分组并宣布自己何时发送数据，但 D 听不到，所以 D 仍然注定会失败。

为了解决这个问题，我们让接收方代表发送方进行竞争。D 不知道何时重新请求，但 C 知道，所以让 C 来代替请求。

当 D 发送 RTS 时，C 知道 D 想要通信，但 C 必须保持安静，直到下一轮竞争开始。要注意的是，C 知道下一轮竞争何时开始，因为它会听到 B 的确认帧（ack）。当下一轮竞争开始时，C 发送一个称为 RTS 请求（RRTS）的新分组。这会立即提醒 D 下一轮已经开始，并让 D 能够立即发送 RTS。这让 D 在竞争回合中有更公平的机会获胜。



![img](https://textbook.cs168.io/assets/wireless/8-028-rrts2.png)

如果你听到 RRTS，这意味着你通信范围内的某个节点正在尝试请求，所以你应该保持安静 2 个时隙，让它们进行 RTS/CTS 交换。

在这个例子中，如果 C 发送 RRTS，B 会听到并保持安静 2 个时隙，这让 D 能够发送 RTS，C 能够发送 CTS。CTS 会告诉 B 保持安静，并允许 D 到 C 的传输进行。

更一般地说，如果你听到了 RTS，但因为其他节点让你保持安静而无法响应，你就应该发送 RRTS。

DS 和 RRTS 有助于同步并确保更公平的竞争回合，但它们并没有解决所有问题。考虑 A 向 B 发送数据，以及 C 向 D 发送数据的情况。假设 C 开始向 D 发送数据。这时，如果 A 发送 RTS，B 可能听不到，因为 RTS 被 C 的传输淹没了。A 的 RTS 要到达 B，只能在 C 的传输间隙的短暂时间内。在这里，A 注定会失败，因为它不知道 C 何时会停止发送，而 C 确切知道自己的发送时间。注意，RRTS 在这里也帮不上忙，因为 RRTS 只在听到 RTS 时才发送，但 B 根本没听到 RTS。B 永远不知道 A 想要通信，所以 B 永远不会代表 A 发送 RRTS 请求。最初的 MACAW 论文没有解决这个问题。