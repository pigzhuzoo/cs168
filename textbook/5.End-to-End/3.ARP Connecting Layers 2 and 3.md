# ARP：连接第二层和第三层

## 连接第二层和第三层

回想一下，当数据包沿着协议栈向下传输到更低层时，会被添加额外的头部。要发送一个 IP 数据包，我们首先在第三层填写其目的 IP 地址。然后，我们将该数据包传递到第二层，在这里我们必须添加一个 MAC 地址才能沿着链路发送数据包。我们要添加哪个 MAC 地址呢？



![img](https://textbook.cs168.io/assets/end-to-end/5-041-arp-blank-mac.png)

首先，我们需要判断目的 IP 地址是位于我们自己的本地网络中，还是位于另一个本地网络中。为了确定这一点，发送方的转发表中会有一个条目，指示本地 IP 地址的范围，有时称为我们的**子网**。例如，该条目可能会说明 192.0.2.0/24 是直接可达的，这意味着 192.0.2.0 到 192.0.2.255 之间的所有地址都在同一个本地网络中。该表中还有一条默认路由，表明所有其他非本地目的地都应转发到路由器。

如果目的 IP 地址在我们的子网中，我们需要某种方法来在目的 IP 地址和该机器对应的 MAC 地址之间进行转换。如果目的地在我们的子网之外，我们需要某种方法将路由器的 IP 地址（来自转发表）转换为其对应的 MAC 地址，以便我们可以将数据包发送到路由器。

一种简单的解决方案是广播每个数据包，这样目的地或路由器肯定会接收并处理它。然而，这是低效的。它迫使所有设备解析每个数据包（例如，读取第三层头部）以检查该数据包是否是发给自己的。此外，如果第二层网络有多个链路，第二层的交换机就必须在所有链路上泛洪该数据包。

更好的方法是将目的 IP 地址转换为其对应的 MAC 地址（如果是本地的）或路由器的 MAC 地址（如果是非本地的），并在第二层单播该数据包。

## ARP：地址解析协议

**ARP（地址解析协议）** 允许机器将 IP 地址转换为其对应的 MAC 地址。

要请求转换，一台机器可以广播一个请求消息：“我的 MAC 地址是`f8:ff:c2:2b:36:16`。拥有 IP 地址 192.0.2.1 的机器的 MAC 地址是什么？”

所有不是该 IP 地址的机器都会忽略该消息。拥有该 IP 地址的用户会向发送方的 MAC 地址单播一个回复，内容为 “我是 192.0.2.1，我的 MAC 地址是`a2:ff:28:02:f2:10`”。

即使没有人询问，机器也可以向所有设备广播自己的 IP 与 MAC 映射。

当你收到一个 IP 与 MAC 的映射时，你可以将其添加到本地的**ARP 表**中，该表会缓存这些映射以供将来使用。该表还包括每个条目的过期时间，因为 IP 地址并不是永久分配给一台计算机的。另一台计算机可能会被分配相同的 IP 地址，或者同一台计算机可能会更改 IP 地址。（待办：接口？）

步骤 1：



![img](https://textbook.cs168.io/assets/end-to-end/5-042-arp1.png)

步骤 2：



![img](https://textbook.cs168.io/assets/end-to-end/5-043-arp2.png)

步骤 3：



![img](https://textbook.cs168.io/assets/end-to-end/5-044-arp3.png)

步骤 4：



![img](https://textbook.cs168.io/assets/end-to-end/5-045-arp4.png)

请注意，ARP 直接运行在第二层，因此所有数据包都是通过以太网而不是 IP 来发送和接收的。



![img](https://textbook.cs168.io/assets/end-to-end/5-046-arp5.png)

## 连接 ARP 和转发表

回想一下，在路由器的转发表中，我们有时会包含一个条目，表明某个主机直接连接到该路由器。

实际上，路由器的转发表包含一个单独的条目，将整个子网范围的 IP 地址映射为直接可达。如果路由器收到一个目的地在该本地范围内的数据包，路由器会运行 ARP 来找到对应的 MAC 地址，并使用第二层将数据包发送到链路上的正确主机。



![img](https://textbook.cs168.io/assets/end-to-end/5-047-direct-route.png)

这也有助于解决多个主机连接在同一链路上的情况。在我们的概念图中，我们会说主机 A 直接连接在端口 1 上。多个主机可能在该链路上，因此通过使用 ARP，我们可以创建一个第二层数据包，仅单播到主机 A，而不是链路上的其他计算机。

给定一个将 192.0.2.0/24 之类的子网映射为直接可达的转发条目，我们如何确定一个给定的 IP 地址是否在该范围内呢？这时候，使用子网掩码而不是斜线记法来表示范围就很有用了。回想一下，要将这个范围用子网掩码表示，我们将所有固定位设置为 1，所有非固定位设置为 0，得到 255.255.255.0。然后，该范围表示为 192.0.2.0，子网掩码为 255.255.255.0。

现在，要检查一个地址是否在该范围内，我们对该地址和子网掩码执行按位与操作。这会将所有非固定的低位清零，只保留固定的高位。然后，我们检查结果是否与 192.0.2.0（该范围中的第一个地址，其中所有非固定位都是 0）匹配。

请注意，当数据包在各个跳之间转发时，第二层的目的地会更改为下一跳的 MAC 地址，以便数据包可以跨链路传输。然而，第三层的目的地在每个跳之间保持不变。



![img](https://textbook.cs168.io/assets/end-to-end/5-048-arp-filled-in-mac.png)

## IPv6 中的邻居发现

ARP 将 IPv4 地址转换为 MAC 地址。要将 IPv6 地址转换为 MAC 地址，我们使用一种类似的协议，称为**邻居发现**。

邻居发现不是广播 IP 与 MAC 转换的请求，而是将请求多播到特定的组，并且每台计算机根据其 IP 地址监听特定的组。例如，所有 IP 地址以 12:3456 结尾的设备可能监听组 MAC 地址 33:33:FF:12:34:56，而所有 IP 地址以 78:90AB 结尾的设备可能监听组 MAC 地址 33:33:FF:78:90:AB。

如果我想要与 IP 地址以 12:3456 结尾的用户对应的 MAC 地址，我可以将这些 IPv6 位插入到组 MAC 地址中，得到 33:33:FF:12:34:56，并且我知道拥有该 IP 地址的用户一定在监听这个组 MAC 地址。



![img](https://textbook.cs168.io/assets/end-to-end/5-049-neighbor-discovery.png)

一些术语：在邻居发现协议中，对映射的请求称为邻居请求，包含映射的回复称为邻居通告。

> （注：文档部分内容可能由 AI 生成）